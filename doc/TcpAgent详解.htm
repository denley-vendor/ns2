
<!-- saved from url=(0112)http://read.pudn.com/downloads91/sourcecode/internet/tcp_ip/351315/ns-tcp%E6%B3%A8%E9%87%8A/tcp20060207.cc__.htm -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=gb18030"><TITLE>ns-tcpexplain.rar tcp20060207.cc</TITLE>
<LINK href="./TcpAgentÏê½â.htm_files/read_style.css" type="text/css" rel="stylesheet"></HEAD><BODY>
<P><A href="http://www.pudn.com/">www.pudn.com</A> &gt; <A href="http://www.pudn.com/downloads91/sourcecode/internet/tcp_ip/detail351315.html">ns-tcpexplain.rar</A> &gt; tcp20060207.cc</P><!-- saved from http://www.pudn.com -->
<SCRIPT src="./TcpAgentÏê½â.htm_files/gg_read1.js"></SCRIPT><FORM action="http://www.pudn.com/search_db.asp" method="get" target="_blank">

&nbsp;<INPUT maxlength="50" size="20" name="keyword">

<INPUT type="submit" value="Search codes">

<BR>
<PRE name="code" class="cc">

#ifndef lint
static const char rcsid[] =
    &quot;@(#) $Header: /nfs/jade/vint/CVSROOT/ns-2/tcp/tcp.cc,v 1.163 2005/06/21 01:48:24 sfloyd Exp $ (LBL)&quot;;
#endif

#include <STDLIB.H>
#include <MATH.H>
#include <SYS/TYPES.H>
#include &quot;ip.h&quot;
#include &quot;tcp.h&quot;
#include &quot;flags.h&quot;
#include &quot;random.h&quot;
#include &quot;basetrace.h&quot;
#include &quot;hdr_qs.h&quot;

int hdr_tcp::offset_;

static class TCPHeaderClass : public PacketHeaderClass {
public:
        TCPHeaderClass() : PacketHeaderClass(&quot;PacketHeader/TCP&quot;,
					     sizeof(hdr_tcp)) {
		bind_offset(&amp;hdr_tcp::offset_);
	}
} class_tcphdr;

static class TcpClass : public TclClass {
public:
	TcpClass() : TclClass(&quot;Agent/TCP&quot;) {}
	TclObject* create(int , const char*const*) {
		return (new TcpAgent());
	}
} class_tcp;

TcpAgent::TcpAgent() 
	: Agent(PT_TCP), 
	  t_seqno_(0), t_rtt_(0), t_srtt_(0), t_rttvar_(0), 
	  t_backoff_(0), ts_peer_(0), ts_echo_(0),
	  tss(NULL), tss_size_(100), 
	  rtx_timer_(this), delsnd_timer_(this), burstsnd_timer_(this), 
	  dupacks_(0), curseq_(0), highest_ack_(0), cwnd_(0), ssthresh_(0), 
	  maxseq_(0), count_(0), rtt_active_(0), rtt_seq_(-1), rtt_ts_(0.0), 
	  lastreset_(0.0), closed_(0), first_decrease_(1), fcnt_(0), 
	  nrexmit_(0), restart_bugfix_(1), cong_action_(0), 
	  ecn_burst_(0), ecn_backoff_(0), ect_(0), 
	  qs_requested_(0), qs_approved_(0),
	  qs_window_(0), qs_cwnd_(0), frto_(0)
	
{
#ifdef TCP_DELAY_BIND_ALL
#else /* ! TCP_DELAY_BIND_ALL */
	// not delay-bound because delay-bound tracevars aren&#39;t yet supported
	bind(&quot;t_seqno_&quot;, &amp;t_seqno_);
	bind(&quot;rtt_&quot;, &amp;t_rtt_);
	bind(&quot;srtt_&quot;, &amp;t_srtt_);
	bind(&quot;rttvar_&quot;, &amp;t_rttvar_);
	bind(&quot;backoff_&quot;, &amp;t_backoff_);
	bind(&quot;dupacks_&quot;, &amp;dupacks_);
	bind(&quot;seqno_&quot;, &amp;curseq_);
	bind(&quot;ack_&quot;, &amp;highest_ack_);
	bind(&quot;cwnd_&quot;, &amp;cwnd_);
	bind(&quot;ssthresh_&quot;, &amp;ssthresh_);
	bind(&quot;maxseq_&quot;, &amp;maxseq_);
        bind(&quot;ndatapack_&quot;, &amp;ndatapack_);
        bind(&quot;ndatabytes_&quot;, &amp;ndatabytes_);
        bind(&quot;nackpack_&quot;, &amp;nackpack_);
        bind(&quot;nrexmit_&quot;, &amp;nrexmit_);
        bind(&quot;nrexmitpack_&quot;, &amp;nrexmitpack_);
        bind(&quot;nrexmitbytes_&quot;, &amp;nrexmitbytes_);
        bind(&quot;necnresponses_&quot;, &amp;necnresponses_);
        bind(&quot;ncwndcuts_&quot;, &amp;ncwndcuts_);
	bind(&quot;ncwndcuts1_&quot;, &amp;ncwndcuts1_);
#endif /* TCP_DELAY_BIND_ALL */

}

void
TcpAgent::delay_bind_init_all()
{

        // Defaults for bound variables should be set in ns-default.tcl.
        delay_bind_init_one(&quot;window_&quot;);
        delay_bind_init_one(&quot;windowInit_&quot;);
        delay_bind_init_one(&quot;windowInitOption_&quot;);

        delay_bind_init_one(&quot;syn_&quot;);
        delay_bind_init_one(&quot;windowOption_&quot;);
        delay_bind_init_one(&quot;windowConstant_&quot;);
        delay_bind_init_one(&quot;windowThresh_&quot;);
        delay_bind_init_one(&quot;delay_growth_&quot;);
        delay_bind_init_one(&quot;overhead_&quot;);
        delay_bind_init_one(&quot;tcpTick_&quot;);
        delay_bind_init_one(&quot;ecn_&quot;);
        delay_bind_init_one(&quot;SetCWRonRetransmit_&quot;);
        delay_bind_init_one(&quot;old_ecn_&quot;);
        delay_bind_init_one(&quot;eln_&quot;);
        delay_bind_init_one(&quot;eln_rxmit_thresh_&quot;);
        delay_bind_init_one(&quot;packetSize_&quot;);
        delay_bind_init_one(&quot;tcpip_base_hdr_size_&quot;);
	delay_bind_init_one(&quot;ts_option_size_&quot;);
        delay_bind_init_one(&quot;bugFix_&quot;);
	delay_bind_init_one(&quot;bugFix_ack_&quot;);
	delay_bind_init_one(&quot;bugFix_ts_&quot;);
	delay_bind_init_one(&quot;lessCareful_&quot;);
        delay_bind_init_one(&quot;slow_start_restart_&quot;);
        delay_bind_init_one(&quot;restart_bugfix_&quot;);
        delay_bind_init_one(&quot;timestamps_&quot;);
	delay_bind_init_one(&quot;ts_resetRTO_&quot;);
        delay_bind_init_one(&quot;maxburst_&quot;);
	delay_bind_init_one(&quot;aggressive_maxburst_&quot;);
        delay_bind_init_one(&quot;maxcwnd_&quot;);
	delay_bind_init_one(&quot;numdupacks_&quot;);
	delay_bind_init_one(&quot;numdupacksFrac_&quot;);
	delay_bind_init_one(&quot;exitFastRetrans_&quot;);
        delay_bind_init_one(&quot;maxrto_&quot;);
	delay_bind_init_one(&quot;minrto_&quot;);
        delay_bind_init_one(&quot;srtt_init_&quot;);
        delay_bind_init_one(&quot;rttvar_init_&quot;);
        delay_bind_init_one(&quot;rtxcur_init_&quot;);
        delay_bind_init_one(&quot;T_SRTT_BITS&quot;);
        delay_bind_init_one(&quot;T_RTTVAR_BITS&quot;);
        delay_bind_init_one(&quot;rttvar_exp_&quot;);
        delay_bind_init_one(&quot;awnd_&quot;);
        delay_bind_init_one(&quot;decrease_num_&quot;);
        delay_bind_init_one(&quot;increase_num_&quot;);
	delay_bind_init_one(&quot;k_parameter_&quot;);
	delay_bind_init_one(&quot;l_parameter_&quot;);
        delay_bind_init_one(&quot;trace_all_oneline_&quot;);
        delay_bind_init_one(&quot;nam_tracevar_&quot;);

        delay_bind_init_one(&quot;QOption_&quot;);
        delay_bind_init_one(&quot;EnblRTTCtr_&quot;);
        delay_bind_init_one(&quot;control_increase_&quot;);
	delay_bind_init_one(&quot;noFastRetrans_&quot;);
	delay_bind_init_one(&quot;precisionReduce_&quot;);
	delay_bind_init_one(&quot;oldCode_&quot;);
	delay_bind_init_one(&quot;useHeaders_&quot;);
	delay_bind_init_one(&quot;low_window_&quot;);
	delay_bind_init_one(&quot;high_window_&quot;);
	delay_bind_init_one(&quot;high_p_&quot;);
	delay_bind_init_one(&quot;high_decrease_&quot;);
	delay_bind_init_one(&quot;max_ssthresh_&quot;);
	delay_bind_init_one(&quot;cwnd_range_&quot;);
	delay_bind_init_one(&quot;timerfix_&quot;);
	delay_bind_init_one(&quot;rfc2988_&quot;);
	delay_bind_init_one(&quot;singledup_&quot;);
	delay_bind_init_one(&quot;LimTransmitFix_&quot;);
	delay_bind_init_one(&quot;rate_request_&quot;);
	delay_bind_init_one(&quot;qs_enabled_&quot;);
	delay_bind_init_one(&quot;tcp_qs_recovery_&quot;);
	delay_bind_init_one(&quot;qs_request_mode_&quot;);
	delay_bind_init_one(&quot;qs_thresh_&quot;);
	delay_bind_init_one(&quot;qs_rtt_&quot;);

	delay_bind_init_one(&quot;frto_enabled_&quot;);
	delay_bind_init_one(&quot;sfrto_enabled_&quot;);
	delay_bind_init_one(&quot;spurious_response_&quot;);

#ifdef TCP_DELAY_BIND_ALL
	// out because delay-bound tracevars aren&#39;t yet supported
        delay_bind_init_one(&quot;t_seqno_&quot;);
        delay_bind_init_one(&quot;rtt_&quot;);
        delay_bind_init_one(&quot;srtt_&quot;);
        delay_bind_init_one(&quot;rttvar_&quot;);
        delay_bind_init_one(&quot;backoff_&quot;);
        delay_bind_init_one(&quot;dupacks_&quot;);
        delay_bind_init_one(&quot;seqno_&quot;);
        delay_bind_init_one(&quot;ack_&quot;);
        delay_bind_init_one(&quot;cwnd_&quot;);
        delay_bind_init_one(&quot;ssthresh_&quot;);
        delay_bind_init_one(&quot;maxseq_&quot;);
        delay_bind_init_one(&quot;ndatapack_&quot;);
        delay_bind_init_one(&quot;ndatabytes_&quot;);
        delay_bind_init_one(&quot;nackpack_&quot;);
        delay_bind_init_one(&quot;nrexmit_&quot;);
        delay_bind_init_one(&quot;nrexmitpack_&quot;);
        delay_bind_init_one(&quot;nrexmitbytes_&quot;);
        delay_bind_init_one(&quot;necnresponses_&quot;);
        delay_bind_init_one(&quot;ncwndcuts_&quot;);
	delay_bind_init_one(&quot;ncwndcuts1_&quot;);
#endif /* TCP_DELAY_BIND_ALL */

	Agent::delay_bind_init_all();

        reset();
}

int
TcpAgent::delay_bind_dispatch(const char *varName, const char *localName, TclObject *tracer)
{
        if (delay_bind(varName, localName, &quot;window_&quot;, &amp;wnd_, tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;windowInit_&quot;, &amp;wnd_init_, tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;windowInitOption_&quot;, &amp;wnd_init_option_, tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;syn_&quot;, &amp;syn_, tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;windowOption_&quot;, &amp;wnd_option_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;windowConstant_&quot;,  &amp;wnd_const_, tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;windowThresh_&quot;, &amp;wnd_th_ , tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;delay_growth_&quot;, &amp;delay_growth_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;overhead_&quot;, &amp;overhead_, tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;tcpTick_&quot;, &amp;tcp_tick_, tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;ecn_&quot;, &amp;ecn_, tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;SetCWRonRetransmit_&quot;, &amp;SetCWRonRetransmit_, tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;old_ecn_&quot;, &amp;old_ecn_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;eln_&quot;, &amp;eln_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;eln_rxmit_thresh_&quot;, &amp;eln_rxmit_thresh_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;packetSize_&quot;, &amp;size_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;tcpip_base_hdr_size_&quot;, &amp;tcpip_base_hdr_size_, tracer)) return TCL_OK;
	if (delay_bind(varName, localName, &quot;ts_option_size_&quot;, &amp;ts_option_size_, tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;bugFix_&quot;, &amp;bug_fix_ , tracer)) return TCL_OK;
	if (delay_bind_bool(varName, localName, &quot;bugFix_ack_&quot;, &amp;bugfix_ack_, tracer)) return TCL_OK;
	if (delay_bind_bool(varName, localName, &quot;bugFix_ts_&quot;, &amp;bugfix_ts_ , tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;lessCareful_&quot;, &amp;less_careful_ , tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;timestamps_&quot;, &amp;ts_option_ , tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;ts_resetRTO_&quot;, &amp;ts_resetRTO_, tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;slow_start_restart_&quot;, &amp;slow_start_restart_ , tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;restart_bugfix_&quot;, &amp;restart_bugfix_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;maxburst_&quot;, &amp;maxburst_ , tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;aggressive_maxburst_&quot;, &amp;aggressive_maxburst_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;maxcwnd_&quot;, &amp;maxcwnd_ , tracer)) return TCL_OK;
	if (delay_bind(varName, localName, &quot;numdupacks_&quot;, &amp;numdupacks_, tracer)) return TCL_OK;
	if (delay_bind(varName, localName, &quot;numdupacksFrac_&quot;, &amp;numdupacksFrac_, tracer)) return TCL_OK;
	if (delay_bind_bool(varName, localName, &quot;exitFastRetrans_&quot;, &amp;exitFastRetrans_, tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;maxrto_&quot;, &amp;maxrto_ , tracer)) return TCL_OK;
	if (delay_bind(varName, localName, &quot;minrto_&quot;, &amp;minrto_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;srtt_init_&quot;, &amp;srtt_init_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;rttvar_init_&quot;, &amp;rttvar_init_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;rtxcur_init_&quot;, &amp;rtxcur_init_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;T_SRTT_BITS&quot;, &amp;T_SRTT_BITS , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;T_RTTVAR_BITS&quot;, &amp;T_RTTVAR_BITS , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;rttvar_exp_&quot;, &amp;rttvar_exp_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;awnd_&quot;, &amp;awnd_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;decrease_num_&quot;, &amp;decrease_num_, tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;increase_num_&quot;, &amp;increase_num_, tracer)) return TCL_OK;
	if (delay_bind(varName, localName, &quot;k_parameter_&quot;, &amp;k_parameter_, tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;l_parameter_&quot;, &amp;l_parameter_, tracer)) return TCL_OK;


        if (delay_bind_bool(varName, localName, &quot;trace_all_oneline_&quot;, &amp;trace_all_oneline_ , tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;nam_tracevar_&quot;, &amp;nam_tracevar_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;QOption_&quot;, &amp;QOption_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;EnblRTTCtr_&quot;, &amp;EnblRTTCtr_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;control_increase_&quot;, &amp;control_increase_ , tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;noFastRetrans_&quot;, &amp;noFastRetrans_, tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;precisionReduce_&quot;, &amp;precision_reduce_, tracer)) return TCL_OK;
	if (delay_bind_bool(varName, localName, &quot;oldCode_&quot;, &amp;oldCode_, tracer)) return TCL_OK;
	if (delay_bind_bool(varName, localName, &quot;useHeaders_&quot;, &amp;useHeaders_, tracer)) return TCL_OK;
	if (delay_bind(varName, localName, &quot;low_window_&quot;, &amp;low_window_, tracer)) return TCL_OK;
	if (delay_bind(varName, localName, &quot;high_window_&quot;, &amp;high_window_, tracer)) return TCL_OK;
	if (delay_bind(varName, localName, &quot;high_p_&quot;, &amp;high_p_, tracer)) return TCL_OK;
	if (delay_bind(varName, localName, &quot;high_decrease_&quot;, &amp;high_decrease_, tracer)) return TCL_OK;
	if (delay_bind(varName, localName, &quot;max_ssthresh_&quot;, &amp;max_ssthresh_, tracer)) return TCL_OK;
	if (delay_bind(varName, localName, &quot;cwnd_range_&quot;, &amp;cwnd_range_, tracer)) return TCL_OK;
	if (delay_bind_bool(varName, localName, &quot;timerfix_&quot;, &amp;timerfix_, tracer)) return TCL_OK;
	if (delay_bind_bool(varName, localName, &quot;rfc2988_&quot;, &amp;rfc2988_, tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;singledup_&quot;, &amp;singledup_ , tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;LimTransmitFix_&quot;, &amp;LimTransmitFix_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;rate_request_&quot;, &amp;rate_request_ , tracer)) return TCL_OK;
        if (delay_bind_bool(varName, localName, &quot;qs_enabled_&quot;, &amp;qs_enabled_ , tracer)) return TCL_OK;
	if (delay_bind_bool(varName, localName, &quot;tcp_qs_recovery_&quot;, &amp;tcp_qs_recovery_, tracer)) return TCL_OK;

	if (delay_bind_bool(varName, localName, &quot;frto_enabled_&quot;, &amp;frto_enabled_, tracer)) return TCL_OK;
	if (delay_bind_bool(varName, localName, &quot;sfrto_enabled_&quot;, &amp;sfrto_enabled_, tracer)) return TCL_OK;
	if (delay_bind_bool(varName, localName, &quot;spurious_response_&quot;, &amp;spurious_response_, tracer)) return TCL_OK;


#ifdef TCP_DELAY_BIND_ALL
	// not if (delay-bound delay-bound tracevars aren&#39;t yet supported
        if (delay_bind(varName, localName, &quot;t_seqno_&quot;, &amp;t_seqno_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;rtt_&quot;, &amp;t_rtt_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;srtt_&quot;, &amp;t_srtt_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;rttvar_&quot;, &amp;t_rttvar_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;backoff_&quot;, &amp;t_backoff_ , tracer)) return TCL_OK;

        if (delay_bind(varName, localName, &quot;dupacks_&quot;, &amp;dupacks_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;seqno_&quot;, &amp;curseq_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;ack_&quot;, &amp;highest_ack_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;cwnd_&quot;, &amp;cwnd_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;ssthresh_&quot;, &amp;ssthresh_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;maxseq_&quot;, &amp;maxseq_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;ndatapack_&quot;, &amp;ndatapack_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;ndatabytes_&quot;, &amp;ndatabytes_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;nackpack_&quot;, &amp;nackpack_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;nrexmit_&quot;, &amp;nrexmit_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;nrexmitpack_&quot;, &amp;nrexmitpack_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;nrexmitbytes_&quot;, &amp;nrexmitbytes_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;necnresponses_&quot;, &amp;necnresponses_ , tracer)) return TCL_OK;
        if (delay_bind(varName, localName, &quot;ncwndcuts_&quot;, &amp;ncwndcuts_ , tracer)) return TCL_OK;
 	if (delay_bind(varName, localName, &quot;ncwndcuts1_&quot;, &amp;ncwndcuts1_ , tracer)) return TCL_OK;

#endif

        return Agent::delay_bind_dispatch(varName, localName, tracer);
}

#define TCP_WRK_SIZE		512
/* Print out all the traced variables whenever any one is changed */
void
TcpAgent::traceAll() {
	if (!channel_)
		return;

	double curtime;
	Scheduler&amp; s = Scheduler::instance();
	char wrk[TCP_WRK_SIZE];

	curtime = &amp;s ? s.clock() : 0;
	snprintf(wrk, TCP_WRK_SIZE,
		 &quot;time: &percnt;-8.5f saddr: &percnt;-2d sport: &percnt;-2d daddr: &percnt;-2d dport:&quot;
		 &quot; &percnt;-2d maxseq: &percnt;-4d hiack: &percnt;-4d seqno: &percnt;-4d cwnd: &percnt;-6.3f&quot;
		 &quot; ssthresh: &percnt;-3d dupacks: &percnt;-2d rtt: &percnt;-6.3f srtt: &percnt;-6.3f&quot;
		 &quot; rttvar: &percnt;-6.3f bkoff: &percnt;-d\n&quot;, curtime, addr(), port(),
		 daddr(), dport(), int(maxseq_), int(highest_ack_),
		 int(t_seqno_), double(cwnd_), int(ssthresh_),
		 int(dupacks_), int(t_rtt_)*tcp_tick_, 
		 (int(t_srtt_) &gt;&gt; T_SRTT_BITS)*tcp_tick_, 
		 int(t_rttvar_)*tcp_tick_/4.0, int(t_backoff_)); 
	(void)Tcl_Write(channel_, wrk, -1);
}

/* Print out just the variable that is modified */
void
TcpAgent::traceVar(TracedVar* v) 
{
	if (!channel_)
		return;

	double curtime;
	Scheduler&amp; s = Scheduler::instance();
	char wrk[TCP_WRK_SIZE];

	curtime = &amp;s ? s.clock() : 0;

	// XXX comparing addresses is faster than comparing names
	if (v == &amp;cwnd_)
		snprintf(wrk, TCP_WRK_SIZE,
			 &quot;&percnt;-8.5f &percnt;-2d &percnt;-2d &percnt;-2d &percnt;-2d &percnt;s &percnt;-6.3f\n&quot;,
			 curtime, addr(), port(), daddr(), dport(),
			 v-&gt;name(), double(*((TracedDouble*) v))); 
 	else if (v == &amp;t_rtt_)
		snprintf(wrk, TCP_WRK_SIZE,
			 &quot;&percnt;-8.5f &percnt;-2d &percnt;-2d &percnt;-2d &percnt;-2d &percnt;s &percnt;-6.3f\n&quot;,
			 curtime, addr(), port(), daddr(), dport(),
			 v-&gt;name(), int(*((TracedInt*) v))*tcp_tick_); 
	else if (v == &amp;t_srtt_)
		snprintf(wrk, TCP_WRK_SIZE,
			 &quot;&percnt;-8.5f &percnt;-2d &percnt;-2d &percnt;-2d &percnt;-2d &percnt;s &percnt;-6.3f\n&quot;,
			 curtime, addr(), port(), daddr(), dport(),
			 v-&gt;name(), 
			 (int(*((TracedInt*) v)) &gt;&gt; T_SRTT_BITS)*tcp_tick_); 
	else if (v == &amp;t_rttvar_)
		snprintf(wrk, TCP_WRK_SIZE,
			 &quot;&percnt;-8.5f &percnt;-2d &percnt;-2d &percnt;-2d &percnt;-2d &percnt;s &percnt;-6.3f\n&quot;,
			 curtime, addr(), port(), daddr(), dport(),
			 v-&gt;name(), 
			 int(*((TracedInt*) v))*tcp_tick_/4.0); 
	else
		snprintf(wrk, TCP_WRK_SIZE,
			 &quot;&percnt;-8.5f &percnt;-2d &percnt;-2d &percnt;-2d &percnt;-2d &percnt;s &percnt;d\n&quot;,
			 curtime, addr(), port(), daddr(), dport(),
			 v-&gt;name(), int(*((TracedInt*) v))); 

	(void)Tcl_Write(channel_, wrk, -1);
}

void
TcpAgent::trace(TracedVar* v) 
{
	if (nam_tracevar_) {
		Agent::trace(v);
	} else if (trace_all_oneline_)
		traceAll();
	else 
		traceVar(v);
}

//
// in 1-way TCP, syn_ indicates we are modeling
// a SYN exchange at the beginning.  If this is true
// and we are delaying growth, then use an initial
// window of one.  If not, we do whatever initial_window()
// says to do.
//

void
TcpAgent::set_initial_window()              //³õÊ¼»¯CWND
{
	if (syn_ &amp;&amp; delay_growth_)         
		cwnd_ = 1.0;                 //Á¬½Ó¿ªÊ¼£¬³õÊ¼´°¿ÚÎª1
	else
		cwnd_ = initial_window();   //
}

void
TcpAgent::reset_qoption()
{
	int now = (int)(Scheduler::instance().clock()/tcp_tick_ + 0.5);

	T_start = now ; 
	RTT_count = 0 ; 
	RTT_prev = 0 ; 
	RTT_goodcount = 1 ; 
	F_counting = 0 ; 
	W_timed = -1 ; 
	F_full = 0 ;
	Backoffs = 0 ; 
}


//reset()½ö±»delay_bind_init_all()µ÷ÓÃ£¬ÓÃÓÚ³õÊ¼»¯²ÎÊý
void
TcpAgent::reset()
{
	rtt_init();
	rtt_seq_ = -1;
	/*XXX lookup variables */
	dupacks_ = 0;
	curseq_ = 0;
	set_initial_window();

	t_seqno_ = 0;
	maxseq_ = -1;
	last_ack_ = -1;
	highest_ack_ = -1;
	ssthresh_ = int(wnd_);       	//wnd_Ä¬ÈÏÎª20£¬SSTHRESH³õÊ¼Ò²Îª20
	if (max_ssthresh_ &gt; 0 &amp;&amp; max_ssthresh_ &lt; ssthresh_) 
		ssthresh_ = max_ssthresh_;         //max_ssthresh_Ä¬ÈÏÎª0£¬±íÊ¾ÎÞÏÞ
	wnd_restart_ = 1.;
	awnd_ = wnd_init_ / 2.0;
	recover_ = 0;
	closed_ = 0;
	last_cwnd_action_ = 0;
	boot_time_ = Random::uniform(tcp_tick_);    //¼ÆËãRTTÊ±ÓÃµ½£¬ÓÃÀ´Ä£ÄâÏµÍ³Æô¶¯Ê±¼ä£¨ÔÚÁ½¸öTCPÊ±ÖÓÖ®¼ä£©
	first_decrease_ = 1;                       //ÓÃÓÚÔÚslowdown()ÖÐÅÐ¶ÏÊÇ·ñµÚÒ»´Î¼õÉÙCWND£¬£½1£¬ÊÇ
	/* W.N.: for removing packets from previous incarnations */
	lastreset_ = Scheduler::instance().clock();

	/* Now these variables will be reset 
	   - Debojyoti Dutta 12th Oct&#39;2000 */
 
	ndatapack_ = 0;
	ndatabytes_ = 0;
	nackpack_ = 0;
	nrexmitbytes_ = 0;
	nrexmit_ = 0;
	nrexmitpack_ = 0;
	necnresponses_ = 0;
	ncwndcuts_ = 0;
	ncwndcuts1_ = 0;

	if (control_increase_) {
		prev_highest_ack_ = highest_ack_ ; 
	}

	if (wnd_option_ == 8) {
		// HighSpeed TCP
		hstcp_.low_p = 1.5/(low_window_*low_window_);
		double highLowWin = log(high_window_)-log(low_window_);
		double highLowP = log(high_p_) - log(hstcp_.low_p);
		hstcp_.dec1 = 
		   0.5 - log(low_window_) * (high_decrease_ - 0.5)/highLowWin;
		hstcp_.dec2 = (high_decrease_ - 0.5)/highLowWin;
        	hstcp_.p1 = 
		  log(hstcp_.low_p) - log(low_window_) * highLowP/highLowWin;
		hstcp_.p2 = highLowP/highLowWin;
	}

	if (QOption_) {
		int now = (int)(Scheduler::instance().clock()/tcp_tick_ + 0.5);
		T_last = now ; 
		T_prev = now ; 
		W_used = 0 ;
		if (EnblRTTCtr_) {
			reset_qoption();
		}
	}
}



/*½öÔÚreset()×÷³õÊ¼»¯Ê±µ÷ÓÃ£¬reset()ÓÖ±»delay_bind_init_all()µ÷ÓÃ
 * Initialize variables for the retransmit timer.
 */
void TcpAgent::rtt_init()       //³õÊ¼»¯RTT¡¢SRTT¡¢RTTVAR¡¢RTXCURºÍ»ØÍË(²¹³¥)Òò×Ó
{
	t_rtt_ = 0;        
	t_srtt_ = int(srtt_init_ / tcp_tick_) &lt;&lt; T_SRTT_BITS;
	t_rttvar_ = int(rttvar_init_ / tcp_tick_) &lt;&lt; T_RTTVAR_BITS;
	t_rtxcur_ = rtxcur_init_;             //³õÊ¼»¯ÖØ´«¶¨Ê±Ê±¼ä
	t_backoff_ = 1;
}



//ÓÉset_rtx_timer()µ÷ÓÃrtt_timeout()Éè¶¨³¬Ê±Öµ
double TcpAgent::rtt_timeout()          //¸ù¾Ý¸ø¶¨µÄt_rtxcur_£¨¿¼ÂÇÉÏÏÂÏÞºÍ»ØÍËÒò×Ó£©
{
	double timeout;
	if (rfc2988_) {           //°´rfc2988µÄËã·¨£¬²»Í¬´¦ÔÚÓÚ2988µÄminrtoÒª³Ë»ØÍËÒò×Ó£¬Ä¬ÈÏÎªFALSE
	// Correction from Tom Kelly to be RFC2988-compliant, by
	// clamping minrto_ before applying t_backoff_.
		if (t_rtxcur_ &lt; minrto_)                   //ÖØ´«³¬Ê±Öµ²»ÄÜÐ¡ÓÚ×îÐ¡RTO
			timeout = minrto_ * t_backoff_;    //·ñÔò°´×îÐ¡ÖµËã 
		else
			timeout = t_rtxcur_ * t_backoff_;  //°´¸ø¶¨ÖµRTXCURËã£¬¶¼Òª³Ë»ØÍËÒò×Ó
	} else {
		timeout = t_rtxcur_ * t_backoff_;    
		if (timeout &lt; minrto_)
			timeout = minrto_;
	}

	if (timeout &gt; maxrto_)                   //ÏÞÖÆ×î´ó³¬Ê±Öµ
		timeout = maxrto_;

        if (timeout &lt; 2.0 * tcp_tick_) {     //³¬Ê±ÖµÎª¸ºÔòÍË³ö£¬Ð¡ÓÚ2¸ötcpÊ±ÖÓÔòÎª2¸ötcpÊ±ÖÓ
		if (timeout &lt; 0) {
			fprintf(stderr, &quot;TcpAgent: negative RTO!  (&percnt;f)\n&quot;,
				timeout);
			exit(1);
		}
		timeout = 2.0 * tcp_tick_;
	}
	return (timeout);
}



//ÓÉnewack()µ÷ÓÃ£¬ÔÙÓÉrecv_newack_helper()µ÷ÓÃ£¬×îÖÕÓÉrecv()µ÷ÓÃ
//ËãµÃµÄt_rtxcur_ÓÉrtt_timeout()µ÷ÓÃ£¬ÔÙÓÉset_rtx_timer()µ÷ÓÃrtt_timeoutÉè¶¨³¬Ê±Öµ£¬set_rtx_timer()Ö÷ÒªÓÉoutput()µÈµ÷ÓÃ
/* This has been modified to use the tahoe code. */
void TcpAgent::rtt_update(double tao)      //¸üÐÂRTT£¬½«Ë«¾«¶ÈµÄRTT×ª»¯³ÉÕûÊýµÄRTT£¬ÓÉ´Ë¼ÆËãt_rtxcur_
{                                                          //taoÎªnewack£¨£©ÖÐµÄnow-ts_echo»ònow-rtt_ts_£¬Ïàµ±ÓÚÎ´ÕûÊý»¯µÄRTT
	double now = Scheduler::instance().clock();
	if (ts_option_)                                  //²ÉÓÃ»ØÓ¦Ê±¼ä´ÁµÄÇé¿ö£¬Ä¬ÈÏ²»²ÉÓÃ
		t_rtt_ = int(tao /tcp_tick_ + 0.5);     //RTTÕûÊý»¯£¬£«0.5±íÊ¾²»ËÄÉáÎåÈë£¬Ö»ÒªÓÐÐ¡Êý£¬¶¼Èë¡£ÆäÖÐtcp_tick_Ä¬ÈÏÎª0.01£¬¼´RTTµÄÖµ¾«È·µ½0.01Ãë
	else {                                              //²»²ÉÓÃÊ±¼ä´ÁµÄÇé¿ö
		double sendtime = now - tao;         //¼ÆËã±¾¶Ë·¢ËÍ¸ÃÐòºÅµÄÊ±¼ä
		sendtime += boot_time_;               //·¢ËÍÊ±¼äÒª¼ÓÉÏbootÊ±¼ä£¬bootÊ±¼äÓÃÓÚÏµÍ³Ä£ÄâÆô¶¯Ê±¼ä£¿£¿ÊÇ¸öËæ»úÊý£¬Ð¡ÓÚÒ»¸ötcpàÖßÕ
		double tickoff = fmod(sendtime, tcp_tick_);        //È¡·¢ËÍÊ±¼ä¶Ôtcp_tick_È¡Ä£µÄÓàÊý£¬ÊÇÕûÊý
		t_rtt_ = int((tao + tickoff) / tcp_tick_);     //¼ÆËã²»²ÉÓÃÊ±¼ä´ÁµÄRTTÊ±¼ä 
	}
	if (t_rtt_ &lt; 1)          //rtt²»ÄÜÐ¡ÓÚÒ»¸öTCPÊ±ÖÓÖÜÆÚ
		t_rtt_ = 1;
	//
	// t_srtt_ has 3 bits to the right of the binary point
	// t_rttvar_ has 2
        // Thus &quot;t_srtt_ &gt;&gt; T_SRTT_BITS&quot; is the actual srtt, 
  	//   and &quot;t_srtt_&quot; is 8*srtt.
	// Similarly, &quot;t_rttvar_ &gt;&gt; T_RTTVAR_BITS&quot; is the actual rttvar,
	//   and &quot;t_rttvar_&quot; is 4*rttvar.
	//ÒÔÏÂ¼ÆËãsrttºÍvarrtt,Ëã·¨²»±Ø¹ØÐÄ
        if (t_srtt_ != 0) {
		register short delta;
		delta = t_rtt_ - (t_srtt_ &gt;&gt; T_SRTT_BITS);	// d = (m - a0)
		if ((t_srtt_ += delta) &lt;= 0)	// srttµÄ¼ÆËã£ºa1 = 7/8 a0 + 1/8 m
			t_srtt_ = 1;
		if (delta &lt; 0)
			delta = -delta;
		delta -= (t_rttvar_ &gt;&gt; T_RTTVAR_BITS);
		if ((t_rttvar_ += delta) &lt;= 0)	// varrttµÄ¼ÆËã£ºvar1 = 3/4 var0 + 1/4 |d|
			t_rttvar_ = 1;
	} else {
		t_srtt_ = t_rtt_ &lt;&lt; T_SRTT_BITS;		// srtt = rtt
		t_rttvar_ = t_rtt_ &lt;&lt; (T_RTTVAR_BITS-1);	// rttvar = rtt / 2
	}
	//
	// Current retransmit value is 
	//    (unscaled) smoothed round trip estimate
	//    plus 2^rttvar_exp_ times (unscaled) rttvar. 
	//
	//¼ÆËãÖØ´«³¬Ê±Ê±¼äRTO= SRTT + max (G, K*RTTVAR)£¬Ëã·¨²»±Ø¹ØÐÄ
	t_rtxcur_ = (((t_rttvar_ &lt;&lt; (rttvar_exp_ + (T_SRTT_BITS - T_RTTVAR_BITS))) +
		t_srtt_)  &gt;&gt; T_SRTT_BITS ) * tcp_tick_;

	return;
}


//ÔÚreset_rtx_timer()ÖÐÊ¹ÓÃ,t_backoffÓÃÓÚÔÚÖØ´«³¬Ê±Ê±¶ÔRTO½øÐÐ·­±¶
void TcpAgent::rtt_backoff()
{
	if (t_backoff_ &lt; 64)          /*t_backoff_¼´RTO²¹³¥Òò×Ó£¬³õÊ¼»¯Îª0£¬Æô¶¯ºóÎª1£¬
	                                ×î´óÎª64£¬¼´×î´óÖØ´«³¬Ê±Ê±¼äÎª£º×î³õµÄRTO*64 */
		t_backoff_ &lt;&lt;= 1;     //Ã¿´Î²¹³¥Òò×Ó*2

	if (t_backoff_ &gt; 8) {         //²¹³¥Òò×Ó&gt;8£¬ËµÃ÷ÖØ·¢ÁË3´ÎÒÔÉÏ£¬Ôò¶ÔrttÆ½¾ùÆ«²îºÍÆ½»¬Öµ×ö³öÐÞÕý
		/*
		 * If backed off this far, clobber the srtt
		 * value, storing it in the mean deviation
		 * instead.
		 */
		t_rttvar_ += (t_srtt_ &gt;&gt; T_SRTT_BITS);
		t_srtt_ = 0;
	}
}

/*
 * headersize:
 *      how big is an IP+TCP header in bytes; include options such as ts
 * this function should be virtual so others (e.g. SACK) can override
 */
int TcpAgent::headersize()  //IP+TCPÍ·´óÐ¡£½»ù±¾Í·´óÐ¡£«Ê±¼äÑ¡Ïî´óÐ¡      
{
        int total = tcpip_base_hdr_size_;
	if (total &lt; 1) {
		fprintf(stderr,
		  &quot;TcpAgent(&percnt;s): warning: tcpip hdr size is only &percnt;d bytes\n&quot;,
		  name(), tcpip_base_hdr_size_);
	}
	if (ts_option_)
		total += ts_option_size_;
        return (total);
}

//output£¨£©·¢ËÍµ¥¸ö·Ö×é£¬±»send_much¡¢send_oneµÈµ÷ÓÃ£¬²»Ö±½ÓÊ¹ÓÃ
void TcpAgent::output(int seqno, int reason)     //reason±íÊ¾ÖØ·¢Ô­Òò£¬±¾¶Ë²»ÓÃ£¬´«¸ø¶Ô¶ËÓÃ    
{
	int force_set_rtx_timer = 0;                        //ºóÃæÓÐhighest_ack_ == maxseq_Ê±£¬¸ÃÖµÎª0
	Packet* p = allocpkt();
	hdr_tcp *tcph = hdr_tcp::access(p);
	hdr_flags* hf = hdr_flags::access(p);
	hdr_ip *iph = hdr_ip::access(p);
	int databytes = hdr_cmn::access(p)-&gt;size();    //¼ÇÂ¼±¾·Ö×éµÄ×Ö½ÚÊý
	tcph-&gt;seqno() = seqno;                                 //µ±Ç°½«·¢ËÍµÄ·Ö×éºÅ
	tcph-&gt;ts() = Scheduler::instance().clock();      //¼ÇÂ¼·¢ËÍµ±Ç°·Ö×éµÄÊ±¼ä´Á
	int is_retransmit = (seqno &lt; maxseq_);           //µ±Ç°·Ö×éºÅ&lt;ÒÔ·¢×î´ó·Ö×éºÅ£¬±íÊ¾±¾´ÎÊÇÖØ´«¸Ã·Ö×é
 
	// Mark packet for diagnosis purposes if we are in Quick-Start Phase
	if (qs_approved_) {                                   //²»¿´
		hf-&gt;qs() = 1;
	}
 
        // store timestamps, with bugfix_ts_.  From Andrei Gurtov. 
	// (A real TCP would use scoreboard for this.)
        if (bugfix_ts_ &amp;&amp; tss==NULL) {              //²»¿´
                tss = (double*) calloc(tss_size_, sizeof(double));
                if (tss==NULL) exit(1);
        }
        //dynamically grow the timestamp array if it&#39;s getting full
        if (bugfix_ts_ &amp;&amp; window() &gt; tss_size_* 0.9) {         //²»¿´
                double *ntss;
                ntss = (double*) calloc(tss_size_*2, sizeof(double));
                printf(&quot;resizing timestamp table\n&quot;);
                if (ntss == NULL) exit(1);
                for (int i=0; i<TSS_SIZE_; i++)="" ntss[(highest_ack_="" +="" i)="" %="" (tss_size_="" *="" 2)]="tss[(highest_ack_" tss_size_];="" free(tss);="" tss_size_="" tss="ntss;" }="" if="" (tss!="NULL)" ²»¿´="" tss[seqno="" tss_size_]="tcph-">ts(); 

	tcph-&gt;ts_echo() = ts_peer_;           //½«¶Ô·½·¢ËÍµÄÊ±¼ä´Á·µ»Ø¸ø¶Ô·½
	tcph-&gt;reason() = reason;              //ÖØ·¢µÄÔ­Òò´«¸ø¶Ô·½
	tcph-&gt;last_rtt() = int(int(t_rtt_)*tcp_tick_*1000);      //½«ÉÏ´ÎµÄRTT½á¹û´«¸ø¶Ô·½£¬ÒÔºÁÃë¼Æ£¬Ö»ÓÃÓÚÍ³¼Æ

	if (ecn_) {                //²»¿´
		hf-&gt;ect() = 1;	// ECN-capable transport
	}
	if (cong_action_ &amp;&amp; (!is_retransmit || SetCWRonRetransmit_)) {   //²»¿´
		hf-&gt;cong_action() = TRUE;  
		cong_action_ = FALSE;
        }
	/* Check if this is the initial SYN packet. */
	if (seqno == 0) {              //ÊÇ·ñÖ§³ÖµÚÒ»¸ö·Ö×é
		if (syn_) {                    //ÊÇµÚÒ»¸ö·Ö×é£¬ÇÒÖ§³ÖSYN
			databytes = 0;         //ÊÇSYN·Ö×é£¬Ôò²»²Î¼ÓndatabytesµÄÍ³¼Æ
			curseq_ += 1;         //Ó¦ÓÃµÄ×î´ó·Ö×éÊý£«1
			hdr_cmn::access(p)-&gt;size() = tcpip_base_hdr_size_;
		}
		if (ecn_) {                   //²»¿´
			hf-&gt;ecnecho() = 1;
//			hf-&gt;cong_action() = 1;
			hf-&gt;ect() = 0;
		}
		if (qs_enabled_) {       //²»¿´
			hdr_qs *qsh = hdr_qs::access(p);

			// dataout is kilobytes queued for sending
			int dataout = (curseq_ - maxseq_ - 1) * (size_ + headersize()) / 1024;
			int qs_rr = rate_request_;
			if (qs_request_mode_ == 1) {
				// PS: Avoid making unnecessary QS requests
				// use a rough estimation of RTT in qs_rtt_
				// to calculate the desired rate from dataout.
				if (dataout * 1000 / qs_rtt_ &lt; qs_rr) {
					qs_rr = dataout * 1000 / qs_rtt_;
				}
				// qs_thresh_ is minimum number of unsent
				// segments needed to activate QS request
				if ((curseq_ - maxseq_ - 1) &lt; qs_thresh_) {
					qs_rr = 0;
				}
			}

		    	if (qs_rr &gt; 0) {
				// QuickStart code from Srikanth Sundarrajan.
				qsh-&gt;flag() = QS_REQUEST;
				qsh-&gt;ttl() = Random::integer(256);
				ttl_diff_ = (iph-&gt;ttl() - qsh-&gt;ttl()) &percnt; 256;
				qsh-&gt;rate() = hdr_qs::Bps_to_rate(qs_rr * 1024);
				qs_requested_ = 1;
		    	} else {
				qsh-&gt;flag() = QS_DISABLE;
			}
		}
	}
	else if (useHeaders_ == true) {               //²»ÊÇµÚÒ»¸ö·Ö×é
		hdr_cmn::access(p)-&gt;size() += headersize();    //¼ÆËã·Ö×éÍ·´óÐ¡
	}
        hdr_cmn::access(p)-&gt;size();

	/* if no outstanding data, be sure to set rtx timer again */
	if (highest_ack_ == maxseq_)           //×î¸ßµÄÒÑÈ·ÈÏACKºÅ£½×î´óÒÑ·¢·Ö×éºÅ£¬±íÊ¾ÒÑ·¢ËÍµÄÈ«¶¼µÃµ½ÁËÈ·ÈÏ£¬
		force_set_rtx_timer = 1;               //¸ÃÊý¾Ý¿Ï¶¨ÎªÐÂµÄÎ´ÊÕµ½ACKµÄÊý¾Ý£¬¿Ï¶¨ÒªÖØÐÂÉèÖÃÖØ´«¶¨Ê±Æ÷£¬Ô­Òò¼ûºóÃæµÄ&ldquo;×¢&rdquo;
	/* call helper function to fill in additional fields */
	output_helper(p);                           

        ++ndatapack_;                          //Í³¼Æ×ÜµÄ·¢ËÍ·Ö×éÊý
        ndatabytes_ += databytes;         //Í³¼Æ×Ü·¢ËÍ×Ö½ÚÊý
	send(p, 0);                                   //·¢ËÍ¸Ã·Ö×é
	if (seqno == curseq_ &amp;&amp; seqno &gt; maxseq_)      //·¢ËÍÐòºÅ£½×î´óÔÊÐí·¢ËÍÐòºÅ£¬±íÊ¾ÒÑ·¢Íê
		idle();  // ¸æËßÓ¦ÓÃ³ÌÐòÒÑ¾­·¢ÍêÊý¾Ý         Tell application I have sent everything so far
	if (seqno &gt; maxseq_) {           //·¢ËÍÐòºÅ&gt;ÉÏ´Î×î´ó·¢ËÍÐòºÅ£¬±íÊ¾ÊÇÐÂ·¢ËÍ·Ö×é
		maxseq_ = seqno;             //ÐÂ·¢ËÍ·Ö×é£¬¼ÇÂ¼×î´ó·¢ËÍÐòºÅ
		if (!rtt_active_) {                //Èç¹ûÉÏÒ»¸öRTTÑù±¾¸Õ¸ÕÊÕµ½£¬rtt_active=1±íÊ¾ÕýÔÚµÈ´ýRTT½ÓÊÕÑù±¾ACK·µ»Ø
			rtt_active_ = 1;              //±íÊ¾±¾·Ö×éÊÇÐÂµÄRTTÑù±¾,rtt¿ªÊ¼ÐÂµÄ¼ÆËã
			if (seqno &gt; rtt_seq_) {    //Èô·¢ËÍÐòºÅ&gt;ÉÏ´ÎRTTÑù±¾ºÅ
				rtt_seq_ = seqno;       //Ôò±¾ÐòºÅÊÇÐÂµÄRTTÑù±¾
				rtt_ts_ = Scheduler::instance().clock();    //ÇÒ¼ÇÂ¼¸ÃÑù±¾µÄ·¢ËÍÊ±¼ä´Á
			}
					
		}
	} else {     //²»ÊÇÐÂ·Ö×éÁË£¬ÔòÊÇÖØ´«
        	++nrexmitpack_;     //Í³¼ÆÖØ´«·Ö×éÊý
		nrexmitbytes_ += databytes;   //Í³¼ÆÖØ´«×Ö½ÚÊý
	}
	if (!(rtx_timer_.status() == TIMER_PENDING) || force_set_rtx_timer) 
	                  /*TIMER_PENDING±íÊ¾³¬Ê±ÖØ´«¶¨Ê±Æ÷ÔÚµÈ´ý×´Ì¬£¬¼´¶Ô¶¨Ê±Æ÷¶¨Ê±µÄ·Ö×éºÅÉÐÎ´ÊÕµ½ACK£¬
	                 Èô¸Ã·Ö×éµÄACK¸Õ¸ÕÊÕµ½£¬»òÔÚÇ¿ÖÆÖØ´«¶¨Ê±Æ÷µÄÇé¿öÊ±£¬¶ÔÖØ´«¶¨Ê±Æ÷ÖØÐÂÉè¶¨³¬Ê± */
		/* No timer pending.  Schedule one. */
		set_rtx_timer();
}
/* 
         ×¢£ºÖØ´«¶¨Ê±µÄÔ­Àí£ºÖ»Éè¶¨Ò»¸öÖØ´«¶¨Ê±Æ÷£¬¶ÔÃ¿Ò»¸ö·¢ËÍµÄ·Ö×éºÅ£¬ÉèÎªA£¬
ÉèÎª¼ì²é¶¨Ê±Æ÷ÊÇ·ñÒÑ¾­ÔÚÓÃ£¬ÈôÃ»ÓÐÓÃ£¬ÔòÉè¶¨¸Ã¶¨Ê±Æ÷£¬´ËÊ±¸Ã¶¨Ê±Æ÷¶ÔÓ¦¸Ã·Ö×éºÅ£»
ÈôÔÚÓÃ£¬Ôò²»ÐÞ¸Ä£¬¼ÌÐø´«¸Ã·Ö×é¡£
        µ±ÊÕµ½¶Ô·½¶Ô·Ö×éAµÄÈ·ÈÏACK£¬Ôò½«ÖØÐÂÉè¶¨¶¨Ê±Æ÷£¬µ½ÏÂÒ»¸ö·Ö×éºÅA+1£¬´ËÊ±¶¨Ê±Æ÷¶ÔÓ¦A+1·Ö×é£»
ÒÔºó£¬Ã¿ÊÕµ½Ò»¸öÐÂÈ·ÈÏ£¬¶¼½«¶¨Ê±Æ÷¶ÔÓ¦µ½¸Ã·Ö×éºÅ+1¡£¼´Ã¿´Î¶¼¶ÔµÚÒ»¸öÎ´±»È·ÈÏµÄ·Ö×é½øÐÐ¼à¿Ø£¬
 ±£Ö¤´Ë·Ö×éÒ»µ©µÃ²»µ½È·ÈÏ¾Í³¬Ê±¡£           
  */



/*
 * Must convert bytes into packets for one-way TCPs.
 * If nbytes == -1, this corresponds to infinite send.  We approximate
 * infinite by a very large number (TCP_MAXSEQ).
 */
 //¸Ã³ÌÐòÓÉÉÏ²ãÓ¦ÓÃµ÷ÓÃ£¬ÓÃÀ´²úÉúTCPÁ÷£¬Íê³ÉtcpÁ¬½Ó¡¢´«Êä¡¢½áÊøÈ«¹ý³Ì£¬¶ø²»ÓÃ¹ÜÊý¾Ý¾ßÌåÔõÃ´´«Êä
void TcpAgent::sendmsg(int nbytes, const char* /*flags*/)      //Èônbyte=-1,±íÊ¾·¢ËÍÔÊÐíµÄÎÞÏÞ¶àÊý¾Ý
{
	if (nbytes == -1 &amp;&amp; curseq_ &lt;= TCP_MAXSEQ)             //ÈôÎÞÏÞ·¢ËÍ£¬ÔòÈ·¶¨·¢ËÍµÄ×î´óÊý¾ÝÁ¿
		curseq_ = TCP_MAXSEQ; 
	else
		curseq_ += (nbytes/size_ + (nbytes&percnt;size_ ? 1 : 0));  //ÓÐÏÞ·¢ËÍ£¬Ôò°´×Ö½ÚÊý¼ÆËã½«·¢ËÍµÄ×ÜµÄÐòÁÐÊý
	send_much(0, 0, maxburst_);              //¾¡Á¿·¢ËÍ¶àµÄÊý¾Ý£¬Ö±µ½·¢ËÍÍê»òÁ¬½ÓÖÕÖ¹£¬maxburst_ÊÇ×î´óÔÊÐí·¢ËÍµÄÊýÖµ£¬Ä¬ÈÏÖµ0£¬±íÊ¾²»ÏÞÊýÁ¿
}

void TcpAgent::advanceby(int delta)
{
  curseq_ += delta;
	if (delta &gt; 0)
		closed_ = 0;
	send_much(0, 0, maxburst_); 
}


int TcpAgent::command(int argc, const char*const* argv)
{
	if (argc == 3) {
		if (strcmp(argv[1], &quot;advance&quot;) == 0) {
			int newseq = atoi(argv[2]);
			if (newseq &gt; maxseq_)
				advanceby(newseq - curseq_);
			else
				advanceby(maxseq_ - curseq_);
			return (TCL_OK);
		}
		if (strcmp(argv[1], &quot;advanceby&quot;) == 0) {
			advanceby(atoi(argv[2]));
			return (TCL_OK);
		}
		if (strcmp(argv[1], &quot;eventtrace&quot;) == 0) {
			et_ = (EventTrace *)TclObject::lookup(argv[2]);
			return (TCL_OK);
		}
		/*
		 * Curtis Villamizar&#39;s trick to transfer tcp connection
		 * parameters to emulate http persistent connections.
		 *
		 * Another way to do the same thing is to open one tcp
		 * object and use start/stop/maxpkts_ or advanceby to control
		 * how much data is sent in each burst.
		 * With a single connection, slow_start_restart_
		 * should be configured as desired.
		 *
		 * This implementation (persist) may not correctly
		 * emulate pure-BSD-based systems which close cwnd
		 * after the connection goes idle (slow-start
		 * restart).  See appendix C in
		 * Jacobson and Karels ``Congestion
		 * Avoidance and Control&#39;&#39; at
		 * <FTP://FTP.EE.LBL.GOV/PAPERS/CONGAVOID.PS.Z>
		 * (*not* the original
		 * &#39;88 paper) for why BSD does this.  See
		 * ``Performance Interactions Between P-HTTP and TCP
		 * Implementations&#39;&#39; in CCR 27(2) for descriptions of
		 * what other systems do the same.
		 *
		 */
		if (strcmp(argv[1], &quot;persist&quot;) == 0) {
			TcpAgent *other
			  = (TcpAgent*)TclObject::lookup(argv[2]);
			cwnd_ = other-&gt;cwnd_;
			awnd_ = other-&gt;awnd_;
			ssthresh_ = other-&gt;ssthresh_;
			t_rtt_ = other-&gt;t_rtt_;
			t_srtt_ = other-&gt;t_srtt_;
			t_rttvar_ = other-&gt;t_rttvar_;
			t_backoff_ = other-&gt;t_backoff_;
			return (TCL_OK);
		}
	}
	return (Agent::command(argc, argv));
}

/*
 * Returns the window size adjusted to allow <NUM> segments past recovery
 * point to be transmitted on next ack.
 */
int TcpAgent::force_wnd(int num)
{
	return recover_ + num - (int)highest_ack_;
}


//ÕûÊýÐÍµÄ·¢ËÍ´°¿Ú£¬·¢ËÍ´°¿Ú£½min(wnd_,cwnd_)
int TcpAgent::window()
{
        /*
         * If F-RTO is enabled and first ack has come in, temporarily open
         * window for sending two segments.
	 * The F-RTO code is from Pasi Sarolahti.  F-RTO is an algorithm
	 * for detecting spurious retransmission timeouts.
         */
        if (frto_ == 2) {
                return (force_wnd(2) &lt; wnd_ ?
                        force_wnd(2) : (int)wnd_);
        } else {
		return (cwnd_ &lt; wnd_ ? (int)cwnd_ : (int)wnd_);
        }
}


//Ë«¾«¶ÈµÄ·¢ËÍ´°¿Ú£¬·¢ËÍ´°¿Ú£½min(wnd_,cwnd_)
double TcpAgent::windowd()
{
	return (cwnd_ &lt; wnd_ ? (double)cwnd_ : (double)wnd_);
}


/*±»recv(),timeout(),timeout_nonrtx(),sendmsg()µÈµ÷ÓÃ
 * Try to send as much data as the window will allow.  The link layer will 
 * do the buffering; we ask the application layer for the size of the packets.
 */
void TcpAgent::send_much(int force, int reason, int maxburst)   
 //ÔÚ´°¿Ú·¶Î§ÄÚ°Ñ¾¡Á¿¶àµÄÊý¾Ý·¢³öÈ¥£¬Íê³ÉÁ¬½Ó¡¢´«Êä¡¢½áÊøÈ«¹ý³Ì
{
	send_idle_helper();
	int win = window();                   //ÕûÐÍµÄ·¢ËÍ´°¿Ú
	int npackets = 0;                     // ±¾´Î·¢ËÍ·Ö×éÊý

	if (!force &amp;&amp; delsnd_timer_.status() == TIMER_PENDING) //Í¨³£force£½0£¬ÔÚ´¦Àí·ÇÖØ´«µÄ³¬Ê±Ê±Îª1
		/*·ÇÖØ´«³¬Ê±£¬¼´ÑÓ³ÙËæ»úÊ±¼ä·¢ËÍÊý¾Ý£¬ÓÃÓÚÄ£ÄâÍøÂçµÄÑÓ³Ù£¬ÓÉtimeout_nonrtx()µ÷ÓÃ£¬ÔÙ±»DelSndTimer::expire()µ÷ÓÃ
	         ÕâÀï±íÊ¾Èç¹û²»ÊÇ·ÇÖØ´«³¬Ê±£¬µ«ÑÓ³Ù¶¨Ê±Æ÷»¹ÔÚ¹¤×÷£¬¾Í²»·¢ËÍ£¬Ö±½ÓÍË³ö  */
		return;
	/* Save time when first packet was sent, for newreno  --Allman */
	if (t_seqno_ == 0)
		firstsent_ = Scheduler::instance().clock();   //¼ÇÂ¼µÚÒ»¸ö·Ö×é·¢ËÍÊ±¼ä£¬newrenoÓÃ
  
	if (burstsnd_timer_.status() == TIMER_PENDING)       //£¿
		return;
	while (t_seqno_ &lt;= highest_ack_ + win &amp;&amp; t_seqno_ &lt; curseq_) {     
		      //·Ö×éºÅÔÚ·¢ËÍ´°¿ÚÄÚ£¬ÇÒÐ¡ÓÚ×î´ó·Ö×éºÅ£¬¼´Âú×ãÌõ¼þ¾Í¾¡Á¿·¢ËÍ£¬²»Âú×ãÌõ¼þ²ÅÍË³ö
		if (overhead_ == 0 || force || qs_approved_) {  
		        //overheadÊÇ¹Ì¶¨Öµ£¬Ä¬ÈÏ0;force£½1£¬¼´·ÇÖØ´«³¬Ê±£»qs£¬¼´¿ìÆô¶¯
		        //Ö»ÒªÊÇÕý³£Çé¿ö£¬»ò·ÇÖØ´«³¬Ê±£¬»ò¿ìÆô¶¯£¬¾Í°´ÏÂÃæÔËÐÐ
			output(t_seqno_, reason);    //·¢ËÍ¸Ã·Ö×é£¬Ô­Òò·¢µ½¶Ô¶Ë
			npackets++;       //ÒÑ·¢ËÍ·Ö×éÊý¼ÇÂ¼
			if (QOption_)
				process_qoption_after_send () ; 
			t_seqno_ ++ ;     //½«Òª·¢ËÍ·Ö×éºÅ£«1
			if (qs_approved_ == 1) {
				// delay = effective RTT / window
				double delay = (double) t_rtt_ * tcp_tick_ / win;
				if (overhead_) { 
					delsnd_timer_.resched(delay + Random::uniform(overhead_));
				} else {
					delsnd_timer_.resched(delay);
				}
				return;
			}
		} else if (!(delsnd_timer_.status() == TIMER_PENDING)) {   
			//²»ÊÇÉÏÃæµÄÈýÖÖÇé¿ö£¬µ«ÑÓ³Ù¶¨Ê±Æ÷Ã»ÓÐµÈ´ýÁË£¬¾ÍÖØÐÂÉèÖÃËæ»úÑÓ³ÙÊ±¼ä£¬²¢·µ»Ø
			/*
			 * Set a delayed send timeout.
			 */
			delsnd_timer_.resched(Random::uniform(overhead_));
			return;
		}
		win = window();    //·¢ËÍÁËÒ»¸ö·Ö×é£¬·¢ËÍ´°¿ÚÖØÐÂ¼ÆËã
		if (maxburst &amp;&amp; npackets == maxburst)   //maxburstÊÇÒ»´Î×î¶à·¢ËÍµÄ·Ö×éÊý£¬Ä¬ÈÏÎª0£¬±íÊ¾²»ÏÞÖÆÊýÁ¿
			break;
	}
	/* call helper function */
	send_helper(maxburst);
}



/*Ö÷ÒªÔÚtimeout()¡¢dupack_action()ÖÐÊ¹ÓÃ
 * We got a timeout or too many duplicate acks.  Clear the retransmit timer.  
 * Resume the sequence one past the last packet acked.  
 * &quot;mild&quot; is 0 for timeouts and Tahoe dup acks, 1 for Reno dup acks.
 * &quot;backoff&quot; is 1 if the timer should be backed off, 0 otherwise.
 */
void TcpAgent::reset_rtx_timer(int mild, int backoff)
{
	if (backoff)           //ÖØ´«Ê±£¬backoff=1,¼ûtimeout(),±íÊ¾Òª¶ÔRTO×ö³öµ÷Õû£¬RTO=RTO*2
		rtt_backoff();
	set_rtx_timer();       //¸ù¾Ýµ÷Õû
	if (!mild)               //³ÌÐòÖ»ÓÃµ½ÁËmild=0µÄÇé¿ö£¬RENOÓÃµ½mild=1µÄÇé¿ö
		t_seqno_ = highest_ack_ + 1;
	rtt_active_ = 0;
}



/*
 * Set retransmit timer using current rtt estimate.  By calling resched(), 
 * it does not matter whether the timer was already running.
 */
void TcpAgent::set_rtx_timer()
{
	rtx_timer_.resched(rtt_timeout());
}



/*Ö»±»newack()µ÷ÓÃ£¬ÓÃÀ´ÉèÖÃÖØ´«¶¨Ê±Æ÷£¬pktÊÇ½ÓÊÕµ½µÄACK·Ö×é
 * Set new retransmission timer if not all outstanding
 * or available data acked, or if we are unable to send because 
 * cwnd is less than one (as when the ECN bit is set when cwnd was 1).
 * Otherwise, if a timer is still outstanding, cancel it.
 */
void TcpAgent::newtimer(Packet* pkt)
{
	hdr_tcp *tcph = hdr_tcp::access(pkt);
	/*
	 * t_seqno_, the next packet to send, is reset (decreased) 
	 *   to highest_ack_ + 1 after a timeout,
	 *   so we also have to check maxseq_, the highest seqno sent.
	 * In addition, if the packet sent after the timeout has
	 *   the ECN bit set, then the returning ACK caused cwnd_ to
	 *   be decreased to less than one, and we can&#39;t send another
	 *   packet until the retransmit timer again expires.
	 *   So we have to check for &quot;cwnd_ &lt; 1&quot; as well.
	 */
	 //µ±Ç°½«·¢ËÍÐòºÅ&gt;±¾´Î½ÓÊÕackºÅ
	if (t_seqno_ &gt; tcph-&gt;seqno() || tcph-&gt;seqno() &lt; maxseq_ || cwnd_ &lt; 1) 
		set_rtx_timer();
	else
		cancel_rtx_timer();       //³ÌÐòÖÐÃ»ÓÐ¸Ã×Ó³ÌÐò
}



/*
 * for experimental, high-speed TCP
 */
double TcpAgent::linear(double x, double x_1, double y_1, double x_2, double y_2)
{
	// The y coordinate factor ranges from y_1 to y_2
	//  as the x coordinate ranges from x_1 to x_2.
	double y = y_1 + ((y_2 - y_1) * ((x - x_1)/(x_2-x_1)));
	return y;
}



/*
 * Limited Slow-Start for large congestion windows.
 * This is only used when max_ssthresh_ is non-zero.
 */
double TcpAgent::limited_slow_start(double cwnd, double max_ssthresh, double increment)
{
	int round = int(cwnd / (double(max_ssthresh)/2.0));
	double increment1 = 1.0/(double(round)); 
	if (increment &lt; increment1)
		increment = increment1;
	return increment;
}



/*
 * For retrieving numdupacks_.
 */
int TcpAgent::numdupacks(double cwnd)
{
        int cwndfraction = (int) cwnd/numdupacksFrac_;
	if (numdupacks_ &gt; cwndfraction) {
	  	return numdupacks_;
        } else {
	  	return cwndfraction;
	}
}



/*
 * Calculating the decrease parameter for highspeed TCP.
 */
double TcpAgent::decrease_param()
{
	double decrease;
	// OLD:
	// decrease = linear(log(cwnd_), log(low_window_), 0.5, log(high_window_), high_decrease_);
	// NEW (but equivalent):
        decrease = hstcp_.dec1 + log(cwnd_) * hstcp_.dec2;  
	return decrease;
}



/*
 * Calculating the increase parameter for highspeed TCP.
 */
double TcpAgent::increase_param()
{
	double increase, decrease, p, answer;
	/* extending the slow-start for high-speed TCP */

	/* for highspeed TCP -- from Sylvia Ratnasamy, */
	/* modifications by Sally Floyd and Evandro de Souza */
 	// p ranges from 1.5/W^2 at congestion window low_window_, to
	//    high_p_ at congestion window high_window_, on a log-log scale.
        // The decrease factor ranges from 0.5 to high_decrease
	//  as the window ranges from low_window to high_window, 
	//  as the log of the window. 
	// For an efficient implementation, this would just be looked up
	//   in a table, with the increase and decrease being a function of the
	//   congestion window.

       if (cwnd_ &lt;= low_window_) { 
		answer = 1 / cwnd_;
       		return answer; 
       } else if (cwnd_ &gt;= hstcp_.cwnd_last_ &amp;&amp; 
	      cwnd_ &lt; hstcp_.cwnd_last_ + cwnd_range_) {
	      // cwnd_range_ can be set to 0 to be disabled,
	      //  or can be set from 1 to 100 
       		answer = hstcp_.increase_last_ / cwnd_;
              	return answer;
       } else { 
		// OLD:
 		// p = exp(linear(log(cwnd_), log(low_window_), log(hstcp_.low_p), log(high_window_), log(high_p_)));
		// NEW, but equivalent:
        	p = exp(hstcp_.p1 + log(cwnd_) * hstcp_.p2);  
        	decrease = decrease_param();
		// OLD:
		// increase = cwnd_*cwnd_*p *(2.0*decrease)/(2.0 - decrease); 
		// NEW, but equivalent:
		increase = cwnd_ * cwnd_ * p /(1/decrease - 0.5);
		//	if (increase &gt; max_increase) { 
		//		increase = max_increase;
		//	} 
		answer = increase / cwnd_;
		hstcp_.cwnd_last_ = cwnd_;
		hstcp_.increase_last_ = increase;
       		return answer;
	}       
}

/*½ö±»recv_newack_helper()µ÷ÓÃ£¬ÔÙ±»recvµ÷ÓÃ£¬ÔÚÊÕµ½ÐÂACKºó£¬ÓÃÓÚÂýÆô¶¯ºÍÓµÈû±ÜÃâ£¬µ÷ÕûCWND£¬²»µ÷ÕûSSTHRESH
 * open up the congestion window
 */
void TcpAgent::opencwnd()
{
	double increment;
	if (cwnd_ &lt; ssthresh_) {     //ÂýÆô¶¯Çé¿ö£¬CWND=CWND+1,Êý¾ÝÖ¸ÊýÔö¼Ó
		/* slow-start (exponential) */
		cwnd_ += 1;
	} else {      //cwnd_&gt;=ssthresh_Çé¿ö£¬CWND=CWND+1/CWND,Êý¾ÝÏßÐÔÔö¼Ó
		/* linear */
		double f;
		switch (wnd_option_) {      //wnd_option_ÊÇ´°¿Ú²ßÂÔ£¬ÏµÍ³¹Ì¶¨ÉèÖÃ£¬Ä¬ÈÏÎª1
		case 0:
			if (++count_ &gt;= cwnd_) {
				count_ = 0;
				++cwnd_;
			}
			break;

		case 1:                               //Ä¬ÈÏÇé¿ö£¬ÆäËûµÄÇé¿ö²»ÓÃ¿´
			/* This is the standard algorithm. */
			increment = increase_num_ / cwnd_; //increase_num_£º¼Ó·¨Ôö²ßÂÔÒò×Ó£¬Ä¬ÈÏ1.0
			                      //Ëã³öÔö¼ÓÁ¿1/CWND
			if ((last_cwnd_action_ == 0 ||         //last_cwnd_action_³õÊ¼»¯Îª0
			  last_cwnd_action_ == CWND_ACTION_TIMEOUT) 
			  &amp;&amp; max_ssthresh_ &gt; 0) {
				increment = limited_slow_start(cwnd_,
				  max_ssthresh_, increment);
			}
			cwnd_ += increment;
			break;

		case 2:
			/* These are window increase algorithms
			 * for experimental purposes only. */
			/* This is the Constant-Rate increase algorithm 
                         *  from the 1991 paper by S. Floyd on &quot;Connections  
			 *  with Multiple Congested Gateways&quot;. 
			 *  The window is increased by roughly 
			 *  wnd_const_*RTT^2 packets per round-trip time.  */
			f = (t_srtt_ &gt;&gt; T_SRTT_BITS) * tcp_tick_;
			f *= f;
			f *= wnd_const_;
			/* f = wnd_const_ * RTT^2 */
			f += fcnt_;
			if (f &gt; cwnd_) {
				fcnt_ = 0;
				++cwnd_;
			} else
				fcnt_ = f;
			break;

		case 3:
			/* The window is increased by roughly 
			 *  awnd_^2 * wnd_const_ packets per RTT,
			 *  for awnd_ the average congestion window. */
			f = awnd_;
			f *= f;
			f *= wnd_const_;
			f += fcnt_;
			if (f &gt; cwnd_) {
				fcnt_ = 0;
				++cwnd_;
			} else
				fcnt_ = f;
			break;

                case 4:
			/* The window is increased by roughly 
			 *  awnd_ * wnd_const_ packets per RTT,
			 *  for awnd_ the average congestion window. */
                        f = awnd_;
                        f *= wnd_const_;
                        f += fcnt_;
                        if (f &gt; cwnd_) {
                                fcnt_ = 0;
                                ++cwnd_;
                        } else
                                fcnt_ = f;
                        break;
		case 5:
			/* The window is increased by roughly wnd_const_*RTT 
			 *  packets per round-trip time, as discussed in
			 *  the 1992 paper by S. Floyd on &quot;On Traffic 
			 *  Phase Effects in Packet-Switched Gateways&quot;. */
                        f = (t_srtt_ &gt;&gt; T_SRTT_BITS) * tcp_tick_;
                        f *= wnd_const_;
                        f += fcnt_;
                        if (f &gt; cwnd_) {
                                fcnt_ = 0;
                                ++cwnd_;
                        } else
                                fcnt_ = f;
                        break;
                case 6:
                        /* binomial controls */ 
                        cwnd_ += increase_num_ / (cwnd_*pow(cwnd_,k_parameter_));                
                        break; 
 		case 8: 
			/* high-speed TCP, RFC 3649 */
			increment = increase_param();
			if ((last_cwnd_action_ == 0 ||
			  last_cwnd_action_ == CWND_ACTION_TIMEOUT) 
			  &amp;&amp; max_ssthresh_ &gt; 0) {
				increment = limited_slow_start(cwnd_,
				  max_ssthresh_, increment);
			}
			cwnd_ += increment;
                        break;
		default:
#ifdef notdef
			/*XXX*/
			error(&quot;illegal window option &percnt;d&quot;, wnd_option_);
#endif
			abort();
		}
	}
	// if maxcwnd_ is set (nonzero), make it the cwnd limit
	if (maxcwnd_ &amp;&amp; (int(cwnd_) &gt; maxcwnd_))    //ÏÞÖÆCWND,²»ÄÜ³¬¹ý×î´óÖµ£¬×î´óÖµÄ¬ÈÏÎª0£¬±íÊ¾²»ÏÞÖÆ
		cwnd_ = maxcwnd_;

	return;
}


//±»timeout¡¢dupack_actionµÈµ÷ÓÃ£¬ÓÃÀ´½µµÍÓµÈû´°¿ÚCWNDºÍÃÅÏÞSSTHRESH
void
TcpAgent::slowdown(int how)
{
	double decrease;  /* added for highspeed - sylvia */
	double win, halfwin, decreasewin;
	int slowstart = 0;    //ÂýÆô¶¯²ÎÊý£¬£½1±íÊ¾ÊÇÂýÆô¶¯
	++ncwndcuts_;        //Í³¼ÆCWND±»¼õÉÙµÄ´ÎÊý£¬²»¹ÜÈÎºÎÔ­Òò
	if (!(how &amp; TCP_IDLE) &amp;&amp; !(how &amp; NO_OUTSTANDING_DATA)){
		++ncwndcuts1_;  //Í³¼ÆÒòÓµÈûCWND±»¼õÉÙµÄ´ÎÊý
	}
	// we are in slowstart for sure if cwnd &lt; ssthresh
	if (cwnd_ &lt; ssthresh_)     	//ÅÐ¶ÏÊÇ·ñÔÚÂýÆô¶¯×´Ì¬
		slowstart = 1;

       //ÏÂÃæÒ»¶Î·Ö±ð°´Ë«¾«¶ÈºÍÕûÐÍ¼ÆËã³ö·¢ËÍ´°¿ÚWND
        if (precision_reduce_) {           //ÊÇ·ñ°´Ë«¾«¶È¼ÆËã·¢ËÍ´°¿Úwin£¬¶ø²»ÊÇÕûÊý¼õ£¬Ä¬ÈÏÎªFALSE
		halfwin = windowd() / 2;
                if (wnd_option_ == 6) {        //wnd_option_Öµ¼ûopencwnd()£¬Ä¬ÈÏ£½1£¬ £½6»ò8²»ÓÃ¿´
                        /* binomial controls */
                        decreasewin = windowd() - (1.0-decrease_num_)*pow(windowd(),l_parameter_);
                } else if (wnd_option_ == 8 &amp;&amp; (cwnd_ &gt; low_window_)) { 
                        /* experimental highspeed TCP */
			decrease = decrease_param();
			//if (decrease &lt; 0.1) 
			//	decrease = 0.1;
			decrease_num_ = decrease;
                        decreasewin = windowd() - (decrease * windowd());
                } else {                 //wnd_option_£½1µ½5µÄÇé¿ö£¬£½1ÊÇÄ¬ÈÏÇé¿ö£¬¼ûopencwnd()
	 		decreasewin = decrease_num_ * windowd(); //decreasewinÎª´°¿Ú¼õÉÙÁ¿
		}
		win = windowd();     //Ë«¾«¶È·¢ËÍ´°¿Ú
	} else  {            //Ä¬ÈÏÇé¿ö£¬°´ÕûÊý¼ÆËã·¢ËÍ´°¿Úwin£¬Ëã·¨Í¬ÉÏÃæÒ»Ñù
		int temp;
		temp = (int)(window() / 2);
		halfwin = (double) temp;
                if (wnd_option_ == 6) {
                        /* binomial controls */
                        temp = (int)(window() - (1.0-decrease_num_)*pow(window(),l_parameter_));
                } else if ((wnd_option_ == 8) &amp;&amp; (cwnd_ &gt; low_window_)) { 
                        /* experimental highspeed TCP */
			decrease = decrease_param();
			//if (decrease &lt; 0.1)
                        //       decrease = 0.1;		
			decrease_num_ = decrease;
                        temp = (int)(windowd() - (decrease * windowd()));
                } else {
 			temp = (int)(decrease_num_ * window());
		}
		decreasewin = (double) temp;
		win = (double) window();    //ÕûÐÍ·¢ËÍ´°¿Ú
	}
	
//ÒÔÏÂ°´ÕÕHOWµÄÖµ£¬Õë¶Ô¸÷ÖÖÇé¿ö£¬¼õÉÙCWNDºÍSSTHRESH	
	if (how &amp; CLOSE_SSTHRESH_HALF)
		// For the first decrease, decrease by half
		// even for non-standard values of decrease_num_.
		if (first_decrease_ == 1 || slowstart ||              //ÔÚµÚÒ»´Î¼õÉÙ£¬ÂýÆô¶¯×´Ì¬»ò³¬Ê±ÖØ´«Ê±£¨ÎªºÎµÚÒ»´Î¼õÉÙÊ±Ò»¶¨ÒªSSTHRESH¼õ°ë£¿£©
			last_cwnd_action_ == CWND_ACTION_TIMEOUT) {   //SSTHRESH½µµÍµ½Ò»°ë£¬wnd_option_£½Ä¬ÈÏ1Ê±£¬ÏÂÃæÁ½ÖÖËã·¨Ó¦¸ÃÒ»Ñù
				                                      //Õý³£Ó¦¸ÃCWND=decreasewin
			// Do we really want halfwin instead of decreasewin
		// after a timeout?
			ssthresh_ = (int) halfwin;
		} else {
			ssthresh_ = (int) decreasewin;                //¼´:SSTHRESH=CWND
		}
        else if (how &amp; THREE_QUARTER_SSTHRESH)        //SSTHRESH¼õÉÙµ½3/4´°¿Ú
		if (ssthresh_ &lt; 3*cwnd_/4)
			ssthresh_  = (int)(3*cwnd_/4);
	if (how &amp; CLOSE_CWND_HALF)                     //CWND¼õÉÙÒ»°ë
		// For the first decrease, decrease by half
		// even for non-standard values of decrease_num_.
		if (first_decrease_ == 1 || slowstart || decrease_num_ == 0.5) {
			cwnd_ = halfwin;
		} else cwnd_ = decreasewin;   //Èç¹ûÉèdecreasewinÎªÆäËûÖµ£¬ÔòÊÇÓÃÓÚ²âÊÔ
        else if (how &amp; CWND_HALF_WITH_MIN) {           //QOPTION,²»¿´
		// We have not thought about how non-standard TCPs, with
		// non-standard values of decrease_num_, should respond
		// after quiescent periods.
                cwnd_ = decreasewin;
                if (cwnd_ &lt; 1)
                        cwnd_ = 1;
	}
	else if (how &amp; CLOSE_CWND_RESTART)         //³¬Ê±Ê±Ê¹SSTHRESH¼õ°ë£¬CWND£½1
		cwnd_ = int(wnd_restart_);         //wnd_restart_³õÊ¼»¯Îª1
	else if (how &amp; CLOSE_CWND_INIT)         //¿ìËÙÆô¶¯¶ªÊ§Ê±Ê¹ÓÃ£¬²»¿´
		cwnd_ = int(wnd_init_);
	else if (how &amp; CLOSE_CWND_ONE)       //ÎÞÏÔÖøÊý¾Ý£¬ÖØ¸´ACK£¬¼°F-RTOÊ±Ê¹ CWND=1
		cwnd_ = 1;
	else if (how &amp; CLOSE_CWND_HALF_WAY) {  //QOPTIONÊ±Ê¹ÓÃ£¬²»¿´
		// cwnd_ = win - (win - W_used)/2 ;
		cwnd_ = W_used + decrease_num_ * (win - W_used);
                if (cwnd_ &lt; 1)
                        cwnd_ = 1;
	}
	if (ssthresh_ &lt; 2)                 //SSTHRESH²»ÄÜÐ¡ÓÚ2
		ssthresh_ = 2;           
	if (how &amp; (CLOSE_CWND_HALF|CLOSE_CWND_RESTART|CLOSE_CWND_INIT|CLOSE_CWND_ONE))
		cong_action_ = TRUE;        //¸ù¾ÝHOWÅÐ¶Ïµ±Ç°ÊÇ·ñÓµÈû

	fcnt_ = count_ = 0;                //ÓÃÓÚwnd_option_£½2£¬3£¬4£¬5µÄÇé¿ö£¬²»¿´
	if (first_decrease_ == 1)          //±¾´ÎÊÇµÚÒ»´Î¼õÉÙ,ÏÂ´Î¾Í²»ÊÇÁË£ºÃ¿´ÎÁ¬½ÓÖ»ÓÐÒ»´Î¼õÉÙ
		first_decrease_ = 0;
	// for event tracing slow start
	if (cwnd_ == 1 || slowstart)        //¸ú×ÙÂýÆô¶¯
		// Not sure if this is best way to capture slow_start
		// This is probably tracing a superset of slowdowns of
		// which all may not be slow_start&#39;s --Padma, 07/&#39;01.
		trace_event(&quot;SLOW_START&quot;);
	


	
}

/*±»recv_newack_helper()µ÷ÓÃ£¬recv_newack_helperÔÙ±»recv()µ÷ÓÃ£¬pktÎª½ÓÊÕACK·Ö×é
 * Process a packet that acks previously unacknowleged data.
 */
void TcpAgent::newack(Packet* pkt)
{
	double now = Scheduler::instance().clock();
	hdr_tcp *tcph = hdr_tcp::access(pkt);
	/* 
	 * Wouldn&#39;t it be better to set the timer *after*
	 * updating the RTT, instead of *before*? 
	 */
	if (!timerfix_) newtimer(pkt);      //²ÉÓÃÔÚ¸üÐÂRTTÒÔÇ°¸üÐÂRTO¶¨Ê±Æ÷µÄ²ßÂÔ
	dupacks_ = 0;                  //ÐÂACK£¬½«ÖØ¸´ACKµÄÍ³¼Æ»Ö¸´Îª0
	last_ack_ = tcph-&gt;seqno();    //	¼ÇÂ¼±¾´ÎÐÂACKºÅµ½last_ack_
	prev_highest_ack_ = highest_ack_ ; 
	highest_ack_ = last_ack_;     //¼ÇÂ¼±¾´ÎÐÂACKºÅµ½last_ack_

	if (t_seqno_ &lt; last_ack_ + 1)     //	¸üÐÂÏÂÒ»´ÎÒª·¢ËÍµÄ°üµÄ¼ÇÂ¼
		t_seqno_ = last_ack_ + 1;      
	/* 
	 * Update RTT only if it&#39;s OK to do so from info in the flags header.
	 * This is needed for protocols in which intermediate agents
	 * in the network intersperse acks (e.g., ack-reconstructors) for
	 * various reasons (without violating e2e semantics).
	 */	
	hdr_flags *fh = hdr_flags::access(pkt);      
		     //ÒÔÏÂÊÇÓÐÊ±¼ä´ÁµÄRTT´¦ÀíÇé¿ö           
	if (!fh-&gt;no_ts_) {                                        //¸ÃACKÓÐÊ±¼ä´Á
		if (ts_option_) {                                 //±¾Á¬½Ó¿ÉÒÔ²ÉÓÃÊ±¼ä´Á
			ts_echo_=tcph-&gt;ts_echo();                 //¼ÇÂ¼¸ÃÐÂACKµÄ»ØÓ¦Ê±¼ä£¬Ïàµ±ÓÚrtt_ts_
			rtt_update(now - tcph-&gt;ts_echo());        //¸üÐÂRTTÖµ£¬now-»ØÓ¦Ê±¼ä¼´ÎªrttÊ±¼ä
			if (ts_resetRTO_ &amp;&amp; (!ect_ || !ecn_backoff_ ||
			    !hdr_flags::access(pkt)-&gt;ecnecho())) { 
				// From Andrei Gurtov
				/* 
				 * Don&#39;t end backoff if still in ECN-Echo with
			 	 * a congestion window of 1 packet. 
				 */
				t_backoff_ = 1;
				ecn_backoff_ = 0;
			}
		}
		if (rtt_active_ &amp;&amp; tcph-&gt;seqno() &gt;= rtt_seq_) {
			if (!ect_ || !ecn_backoff_ || 
				!hdr_flags::access(pkt)-&gt;ecnecho()) {
				/* 
				 * Don&#39;t end backoff if still in ECN-Echo with
			 	 * a congestion window of 1 packet. 
				 */
				t_backoff_ = 1;
				ecn_backoff_ = 0;
			}
			rtt_active_ = 0;
			if (!ts_option_)                          //±¾Á¬½Ó²»ÄÜ²ÉÓÃÊ±¼ä´Á
				rtt_update(now - rtt_ts_);
		}
	}
	             
	if (timerfix_) newtimer(pkt);            //²ÉÓÃÔÚ¸üÐÂRTTÒÔÇ°¸üÐÂRTO¶¨Ê±Æ÷µÄ²ßÂÔ£¬¸ü¿ÆÑ§
	/* update average window */       //¸üÐÂÆ½¾ù´°¿Úawnd_=(1 - wnd_th_)*awnd+wnd_th_*cwnd
	awnd_ *= 1.0 - wnd_th_;
	awnd_ += wnd_th_ * cwnd_;
}


/*
 * Respond either to a source quench or to a congestion indication bit.
 * This is done at most once a roundtrip time;  after a source quench,
 * another one will not be done until the last packet transmitted before
 * the previous source quench has been ACKed.
 *
 * Note that this procedure is called before &quot;highest_ack_&quot; is
 * updated to reflect the current ACK packet.  
 */
void TcpAgent::ecn(int seqno)
{
	if (seqno &gt; recover_ || 
	      last_cwnd_action_ == CWND_ACTION_TIMEOUT) {
		recover_ =  maxseq_;
		last_cwnd_action_ = CWND_ACTION_ECN;
		if (cwnd_ &lt;= 1.0) {
			if (ecn_backoff_) 
				rtt_backoff();
			else ecn_backoff_ = 1;
		} else ecn_backoff_ = 0;
		slowdown(CLOSE_CWND_HALF|CLOSE_SSTHRESH_HALF);
		++necnresponses_ ;
		// added by sylvia to count number of ecn responses 
	}
}

/*
 *  Is the connection limited by the network (instead of by a lack
 *    of data from the application?
 */
int TcpAgent::network_limited() {
	int win = window () ;
	if (t_seqno_ &gt; (prev_highest_ack_ + win))
		return 1;
	else
		return 0;
}

//ÓÉrecv()µ÷ÓÃ£¬ÊÕµ½ÐÂACKµÄÇé¿ö£¬ÓÃÓÚÐÂack´¦Àí£¨newack(pkt)£©£¬¼°cwndÉèÖÃ£¬¹Ø±ÕÁ¬½ÓµÈ´¦Àí
void TcpAgent::recv_newack_helper(Packet *pkt) {
	//hdr_tcp *tcph = hdr_tcp::access(pkt);
	newack(pkt);                                                  //ÐÂACK´¦Àí
        if (qs_window_ &amp;&amp; highest_ack_ &gt;= qs_window_) {                     //QS´¦Àí£¬²»ÓÃ¿´
                // All segments in the QS window have been acknowledged.
                // We can exit the Quick-Start phase.
                qs_window_ = 0;
        }
	if (!ect_ || !hdr_flags::access(pkt)-&gt;ecnecho() ||        //²»ÊÇECN·Ö×é£¬»ò&quot;old ecn&quot;¡£Õý³£µÄÐÂ·Ö×é
		(old_ecn_ &amp;&amp; ecn_burst_)) {
		/* If &quot;old_ecn&quot;, this is not the first ACK carrying ECN-Echo
		 * after a period of ACKs without ECN-Echo.
		 * Therefore, open the congestion window. */
		/* if control option is set, and the sender is not
			 window limited, then do not increase the window size 
			control_increase_ÉèÎª1£¬Ôò·¢·½´°¿Ú²»ÊÜÏÞ£¬²»ÓÃÔö¼Ó´°¿Ú´óÐ¡£¿
			 */
		
		if (!control_increase_ ||                 //control_increase_ÏµÍ³¹Ì¶¨Öµ£¬Ä¬ÈÏÎª0
		   (control_increase_ &amp;&amp; (network_limited() == 1))) 
	      		opencwnd();            //Õý³£Çé¿ö£¬ÊÕµ½ÐÂACK£¬¾Í´ò¿ªCWNDÉèÖÃ
	}
	if (ect_) {                                              //ÊÇECN·Ö×é
		if (!hdr_flags::access(pkt)-&gt;ecnecho())
			ecn_backoff_ = 0;
		if (!ecn_burst_ &amp;&amp; hdr_flags::access(pkt)-&gt;ecnecho())
			ecn_burst_ = TRUE;
		else if (ecn_burst_ &amp;&amp; ! hdr_flags::access(pkt)-&gt;ecnecho())
			ecn_burst_ = FALSE;
	}
	if (!ect_ &amp;&amp; hdr_flags::access(pkt)-&gt;ecnecho() &amp;&amp;
		!hdr_flags::access(pkt)-&gt;cong_action())
		ect_ = 1;
	/* if the connection is done, call finish() */
	if ((highest_ack_ &gt;= curseq_-1) &amp;&amp; !closed_) {      //×î´óACK&gt;=Ó¦ÓÃ³ÌÐò×î´óÖµ-1£¬±íÊ¾Á¬½Ó½áÊø
		closed_ = 1;          //¹Ø±ÕÁ¬½Ó£¬ÔËÐÐfinish();                      
		finish();
	}
	if (QOption_ &amp;&amp; curseq_ == highest_ack_ +1) {     //²»¿´
		cancel_rtx_timer();
	}
	if (frto_ == 1) {                              
		/*
		 * New ack after RTO. If F-RTO is enabled, try to transmit new
		 * previously unsent segments.
		 * If there are no new data or receiver window limits the
		 * transmission, revert to traditional recovery.
		 */
		if (recover_ + 1 &gt;= highest_ack_ + wnd_ ||
		    recover_ + 1 &gt;= curseq_) {
			frto_ = 0;
 		} else if (highest_ack_ == recover_) {
 			/*
 			 * F-RTO step 2a) RTO retransmission fixes whole
			 * window =&gt; cancel F-RTO
 			 */
 			frto_ = 0;
		} else {
			t_seqno_ = recover_ + 1;
			frto_ = 2;
		}
	} else if (frto_ == 2) {
		/*
		 * Second new ack after RTO. If F-RTO is enabled, RTO can be
		 * declared spurious
		 */
		spurious_timeout();
	}
}

/*
 * Set the initial window. 
 */
double
TcpAgent::initial_window()
{
        // If Quick-Start Request was approved, use that as a basis for
        // initial window
        if (qs_cwnd_) {
                return (qs_cwnd_);
        }
	//
	// init_option = 1: static iw of wnd_init_
	//
	if (wnd_init_option_ == 1) {    //Ê¹ÓÃÄ¬ÈÏ³õÊ¼Æô¶¯´°¿Ú
		return (wnd_init_);
	}
        else if (wnd_init_option_ == 2) {  //Ê¹ÓÃ´óµÄ³õÊ¼Æô¶¯´°¿Ú
		// do iw according to Internet draft
 		if (size_ &lt;= 1095) {        //¸ù¾Ý·Ö×éÊý¾Ý´óÐ¡·Ö¶Î
			return (4.0);
	 	} else if (size_ &lt; 2190) {
			return (3.0);
		} else {
			return (2.0);
		}
	}
	// XXX what should we return here???
	fprintf(stderr, &quot;Wrong number of wnd_init_option_ &percnt;d\n&quot;, 
		wnd_init_option_);
	abort();
	return (2.0); // XXX make msvc happy.
}

/*
 * Dupack-action: what to do on a DUP ACK.  After the initial check
 * of &#39;recover&#39; below, this function implements the following truth
 * table:
 *
 *	bugfix	ecn	last-cwnd == ecn	action
 *
 *	0	0	0			tahoe_action
 *	0	0	1			tahoe_action	[impossible]
 *	0	1	0			tahoe_action
 *	0	1	1			slow-start, return
 *	1	0	0			nothing
 *	1	0	1			nothing		[impossible]
 *	1	1	0			nothing
 *	1	1	1			slow-start, return
 */

/* 
 * A first or second duplicate acknowledgement has arrived, and
 * singledup_ is enabled.
 * If the receiver&#39;s advertised window permits, and we are exceeding our
 * congestion window by less than numdupacks_, then send a new packet.
 */
//·¢ËÍµ¥¸ö·Ö×é£¬¿ÉÒÔÊÇÖØ´«·Ö×é
void
TcpAgent::send_one()
{
	if (t_seqno_ &lt;= highest_ack_ + wnd_ &amp;&amp; t_seqno_ &lt; curseq_ &amp;&amp;
		t_seqno_ &lt;= highest_ack_ + cwnd_ + dupacks_ ) {
		output(t_seqno_, 0);  //
		if (QOption_)
			process_qoption_after_send () ;
		t_seqno_ ++ ;
		// send_helper(); ??
	}
	return;
}


//ÔÚrecv()ÖÐ£¬Âú×ãÁË¿ìËÙÖØ´«µÄÌõ¼þºóµ÷ÓÃ£¬ÓÃÓÚ¼õÉÙCWNDºÍSSTHRESH,²¢ÖØÆôÖØ´«¶¨Ê±Æ÷
void
TcpAgent::dupack_action()    
{
	int recovered = (highest_ack_ &gt; recover_);  
	            //recover_ÓÃÓÚ¼ÇÂ¼³¬Ê±ºÍ¿ìËÙÖØ´«Ç°ÒÑ·¢ËÍ·Ö×éµÄ×î´óÐòºÅ,ÓÃÓÚF-RTO
	if (recovered || (!bug_fix_ &amp;&amp; !ecn_)) {
		goto tahoe_action;                      //Ìøµ½tahoe_action
	}

	if (ecn_ &amp;&amp; last_cwnd_action_ == CWND_ACTION_ECN) {        //²»¿´
		last_cwnd_action_ = CWND_ACTION_DUPACK;
		slowdown(CLOSE_CWND_ONE);
		reset_rtx_timer(0,0);
		return;
	}

	if (bug_fix_) {
		/*
		 * The line below, for &quot;bug_fix_&quot; true, avoids
		 * problems with multiple fast retransmits in one
		 * window of data. 
		 */
		return;
	}

tahoe_action:                                     //tcp tahoe
        recover_ = maxseq_;                  //¼ÇÂ¼³¬Ê±ºÍ¿ìËÙÖØ´«Ç°ÒÑ·¢ËÍ·Ö×éµÄ×î´óÐòºÅ
        if (!lossQuickStart()) {                //
		// we are now going to fast-retransmit and willtrace that event
		trace_event(&quot;FAST_RETX&quot;);         //¸ú×Ù¿ìËÙÖØ´«
		last_cwnd_action_ = CWND_ACTION_DUPACK;    //¼ÇÂ¼±¾´Î¿ìËÙÖØ´«
		slowdown(CLOSE_SSTHRESH_HALF|CLOSE_CWND_ONE);    //SSTHRESH¼õ°ë£¬CWND£½1
	}
	reset_rtx_timer(0,0);             	//ÖØÉèÖØ´«¶¨Ê±Æ÷
	return;
}

/*
 * When exiting QuickStart, reduce the congestion window to the
 *   size that was actually used.
 */
void TcpAgent::endQuickStart()
{
	qs_approved_ = 0;
        qs_cwnd_ = 0;
        qs_window_ = maxseq_;
	int new_cwnd = maxseq_ - last_ack_;
	if (new_cwnd &gt; 1 &amp;&amp; new_cwnd &lt; cwnd_) {
	 	cwnd_ = new_cwnd;
		if (cwnd_ &lt; initial_window()) 
			cwnd_ = initial_window();
	}
}

void TcpAgent::processQuickStart(Packet *pkt)
{
	// QuickStart code from Srikanth Sundarrajan.
	hdr_tcp *tcph = hdr_tcp::access(pkt);
	hdr_qs *qsh = hdr_qs::access(pkt);
	double now = Scheduler::instance().clock();
	int app_rate;

        // printf(&quot;flag: &percnt;d ttl: &percnt;d ttl_diff: &percnt;d rate: &percnt;d\n&quot;, qsh-&gt;flag(),
	//     qsh-&gt;ttl(), ttl_diff_, qsh-&gt;rate());
	qs_requested_ = 0;
	qs_approved_ = 0;
	if (qsh-&gt;flag() == QS_RESPONSE &amp;&amp; qsh-&gt;ttl() == ttl_diff_ &amp;&amp; 
            qsh-&gt;rate() &gt; 0) {
                app_rate = (int) (hdr_qs::rate_to_Bps(qsh-&gt;rate()) *
                      (now - tcph-&gt;ts_echo()) / (size_ + headersize()));
#ifdef QS_DEBUG
		printf(&quot;Quick Start approved, rate &percnt;d, window &percnt;d\n&quot;, 
				     qsh-&gt;rate(), app_rate);
#endif
                if (app_rate &gt; initial_window()) {
			qs_cwnd_ = app_rate;
                        qs_approved_ = 1;
                }
        } else { // Quick Start rejected
#ifdef QS_DEBUG
                printf(&quot;Quick Start rejected\n&quot;);
#endif
        }

}



/*
 * ACK has been received, hook from recv()
 */
void TcpAgent::recv_frto_helper(Packet *pkt)
{
	hdr_tcp *tcph = hdr_tcp::access(pkt);
	if (tcph-&gt;seqno() == last_ack_ &amp;&amp; frto_ != 0) {
		/*
		 * Duplicate ACK while in F-RTO indicates that the
		 * timeout was valid. Go to slow start retransmissions.
		 */
		t_seqno_ = highest_ack_ + 1;
		cwnd_ = frto_;
		frto_ = 0;

		// Must zero dupacks (in order to trigger send_much at recv)
		// dupacks is increased in recv after exiting this function
		dupacks_ = -1;
	}
}


/*
 * A spurious timeout has been detected. Do appropriate actions.
 */
void TcpAgent::spurious_timeout()
{
	frto_ = 0;

	switch (spurious_response_) {
	case 1:
	default:
		/*
		 * Full revert of congestion window
		 * (FlightSize before last acknowledgment)
		 */
		cwnd_ = t_seqno_ - prev_highest_ack_;
		break;
 
	case 2:
		/*
		 * cwnd = reduced ssthresh (approx. half of the earlier pipe)
		 */
		cwnd_ = ssthresh_; break;
	case 3:
		/*
		 * slow start, but without retransmissions
		 */
		cwnd_ = 1; break;
	}

	/*
	 * Revert ssthresh to size before retransmission timeout
	 */
	ssthresh_ = pipe_prev_;

	/* If timeout was spurious, bugfix is not needed */
	recover_ = highest_ack_ - 1;
}


/*
 * Loss occurred in Quick-Start window.
 * If Quick-Start is enabled, packet loss in the QS phase should
 * trigger slow start instead of the regular fast retransmit,
 * see [draft-amit-quick-start-03.txt] (to appear).
 * We use variable tcp_qs_recovery_ to toggle this behaviour on and off.
 * If tcp_qs_recovery_ is true, initiate slow start to probe for
 * a correct window size.
 *
 * Return value: non-zero if Quick-Start specific loss recovery took place
 */
int TcpAgent::lossQuickStart()
{
       if (qs_window_ &amp;&amp; tcp_qs_recovery_) {
                //recover_ = maxseq_;
                //reset_rtx_timer(1,0);
                slowdown(CLOSE_CWND_INIT);
		// reset ssthresh to half of W-D/2?
                qs_window_ = 0;
                output(last_ack_ + 1, TCP_REASON_DUPACK);
                return 1;
       }
       return 0;
}




/*
 * main reception path - should only see acks, otherwise the
 * network connections are misconfigured
 */
void TcpAgent::recv(Packet *pkt, Handler*)
{
	hdr_tcp *tcph = hdr_tcp::access(pkt);               //½ÓÊÜ·Ö×éTCPÍ·
	int valid_ack = 0;
	if (qs_approved_ == 1 &amp;&amp; tcph-&gt;seqno() &gt; last_ack_)           //¿ìÆô¶¯´¦Àí£¬²»¿´ 
		endQuickStart();
	if (qs_requested_ == 1)
		processQuickStart(pkt);
#ifdef notdef
	if (pkt-&gt;type_ != PT_ACK) {                                         //ACK°üÀàÐÍÅÐ¶Ï
		Tcl::instance().evalf(&quot;&percnt;s error \&quot;received non-ack\&quot;&quot;,
				      name());
		Packet::free(pkt);
		return;                                                                   //²»ÊÇACK°ü£¬ÍË³ö
	}
#endif
	/* W.N.: check if this is from a previous incarnation */
	if (tcph-&gt;ts() &lt; lastreset_) {            //ÅÐ¶ÏÊÇ·ñÉÏ´ÎÁ¬½ÓµÄÊ¬Ìå°ü
		// Remove packet and do nothing
		Packet::free(pkt);                    //ÊÇÊ¬Ìå·Ö×é£¬ÊÍ·Å¸Ã·Ö×éÄÚ´æ£¬²¢ÍË³ö
		return;
	}
	++nackpack_;                              //ACK°üÊý£«1
	ts_peer_ = tcph-&gt;ts();                   //¼ÇÂ¼¶Ô¶Ë·¢´ËACK°üÊ±µÄÊ±¼ä
	int ecnecho = hdr_flags::access(pkt)-&gt;ecnecho();       //ECN´¦Àí£¬²»¿´
	if (ecnecho &amp;&amp; ecn_)
		ecn(tcph-&gt;seqno());
	recv_helper(pkt);                                                      //helper´¦Àí£¬²»±Ø¿´
	recv_frto_helper(pkt);
	/* grow cwnd and check if the connection is done */ 
	if (tcph-&gt;seqno() &gt; last_ack_) {                 //±¾ACKÐòºÅ&gt;ÉÏ´Î¼ÇÂ¼µÄACKÐòºÅ£¬±íÊ¾ÊÇÐÂµÄACK       
		recv_newack_helper(pkt);                     //ÐÂACKµÄhelper
		if (last_ack_ == 0 &amp;&amp; delay_growth_) {     //ÊÇÁ¬½ÓÒÔÀ´µÄµÚÒ»¸öACK
			cwnd_ = initial_window();                    //³õÊ¼»¯CWND
		}                                                      //ÏÂÃæÒ»¶Î´¦ÀíÖØ¸´ACK
	} else if (tcph-&gt;seqno() == last_ack_) {                // ²»ÊÇÐÂACK,ÊÇÉÏ´ÎµÄÖØ¸´ACK
                if (hdr_flags::access(pkt)-&gt;eln_ &amp;&amp; eln_) {            //ELN´¦Àí£¬²»±Ø¿´
                        tcp_eln(pkt);
                        return;
                }
		if (++dupacks_ == numdupacks_ &amp;&amp; !noFastRetrans_) {   //ÖØ¸´ACKÊý£½numdupacks²¢ÇÒÔÊÐí¿ìËÙÖØ´«Ê±£¬±íÊ¾Âú×ãÁË¿ìËÙ¿ìËÙÖØ´«Ìõ¼þ£¬µ«tahoeÖÐ²»Ö§³Ö¿ìËÙÖØ´«
			dupack_action();                                           //¿ìËÙÖØ´«¶¯×÷£¬ÓÃÓÚ¼õÉÙCWNDºÍSSTHRESH,²¢ÖØÆôÖØ´«¶¨Ê±Æ÷
		} else if (dupacks_ &lt; numdupacks_ &amp;&amp; singledup_ ) {    //ÕâÀïsingledup_ÊÇÏµÍ³µÄ¹Ì¶¨Öµ£¬ÕâÀïÊ¹TCP²»²ÉÓÃ¿ìËÙÖØ´«²ßÂÔ£¬
			send_one();                                                            //¶øÊÇÊÕµ½Ò»¸ö»òÁ½¸öÖØ¸´ACK£¬¾ÍÖØ´«µÄ²ßÂÔ
		}
	}

	if (QOption_ &amp;&amp; EnblRTTCtr_)                                            //QOPTION£¬²»±Ø¿´
		process_qoption_after_ack (tcph-&gt;seqno());

	if (tcph-&gt;seqno() &gt;= last_ack_)                                          //±¾ACKÐòºÅ&gt;=ÉÏ´ÎACK£¬±íÊ¾ÊÇÐÂACK»òÖØ¸´ACK,ÊÇºÏ·¨µÄ
		// Check if ACK is valid.  Suggestion by Mark Allman. 
		valid_ack = 1;
	Packet::free(pkt);                                                             //ºÏ·¨£¬»ØÊÕ¸Ã·Ö×éÄÚ´æ
	/*
	 * Try to send more data.
	 */
	if (valid_ack || aggressive_maxburst_)   //aggressive_maxburst_Ä¬ÈÏÎª1£¬½ÓÊÕ´¦ÀíÍêÁË£¬¼ÌÐø·¢ËÍ¾¡¿ÉÄÜ¶àµÄ·Ö×é
		send_much(0, 0, maxburst_);
}




/*´¦Àí·ÇÖØ´«µÄ³¬Ê±£¬¼´ÓÃÓÚ½«·¢ËÍÊý¾Ý½øÐÐËæ»úÑÓ³Ù£¬Ä£ÄâÍøÂçµÄÑÓ³ÙÇé¿ö
 * Process timeout events other than rtx timeout. Having this as a separate 
 * function allows derived classes to make alterations/enhancements (e.g.,
 * response to new types of timeout events).
 */ 
void TcpAgent::timeout_nonrtx(int tno) 
{
	if (tno == TCP_TIMER_DELSND)  {
	 /*
	 	* delayed-send timer, with random overhead
	 	* to avoid phase effects
	 	*/
		send_much(1, TCP_REASON_TIMEOUT, maxburst_);
	}
}




//Ö±½Ó±»¼¸¸ö¶¨Ê±Æ÷µÄexpire()µ÷ÓÃ£¬¼´ÔÚ³¬Ê±ºó£¬¸÷¶¨Ê±Æ÷Í¨¹ý³¬Ê±ÀàÐÍ£¬Ñ¡ÔñÖ´ÐÐÏÂÃæ´úÂë	
void TcpAgent::timeout(int tno)
{
	/* retransmit timer */
	if (tno == TCP_TIMER_RTX) {               //³¬Ê±ÖØ´«µÄÇé¿ö

		// There has been a timeout - will trace this event
		trace_event(&quot;TIMEOUT&quot;);              //¸ú×Ù³¬Ê±

		frto_ = 0;                                  //F-RTO        
		// Set pipe_prev as per Eifel Response
		pipe_prev_ = (window() &gt; ssthresh_) ?
			window() : (int)ssthresh_;

	        if (cwnd_ &lt; 1) cwnd_ = 1;             //CWNDÖÁÉÙÎª1
		if (qs_approved_ == 1) qs_approved_ = 0;
		
		//´Ë¶Î¶ÔSSTHRESHºÍCWND×ö³öµ÷Õû
		if (highest_ack_ == maxseq_ &amp;&amp; !slow_start_restart_) {
			/* ÎÞÏÔÖøÊý¾Ý£º¼´·¢ËÍµÄÊý¾Ý¶¼ÒÑÊÕµ½ÁËÓ¦´ð
			   ÕâÊÇÎÞÏÔÖøÊý¾Ý²¢ÇÒ²»ÊÇÂýÆô¶¯ÖØÆôµÄÇé¿ö£¬Ê²Ã´¶¼²»×ö£¬Õý³£²»»á³öÏÖ
			 * TCP option:
			 * If no outstanding data, then don&#39;t do anything.  
			 */
			 // Should this return be here?
			 // What if CWND_ACTION_ECN and cwnd &lt; 1?
			 // return;
		} else {  //
			recover_ = maxseq_;
			if (highest_ack_ == -1 &amp;&amp; wnd_init_option_ == 2)
				/* ÉÏ´ÎackºÅÎª£­1£¬±íÊ¾Î´ÊÕµ½ACK,µÚÒ»¸ö·Ö×é¶ªÊ§ÁË
				 * First packet dropped, so don&#39;t use larger
				 * initial windows. 
				 */
				wnd_init_option_ = 1;
			if (highest_ack_ == maxseq_ &amp;&amp; restart_bugfix_)
			       /* ÎÞÏÔÖøÊý¾ÝµÄÇé¿ö
				* if there is no outstanding data, don&#39;t cut 
				* down ssthresh_.
				*/
				slowdown(CLOSE_CWND_ONE|NO_OUTSTANDING_DATA);
			else if (highest_ack_ &lt; recover_ &amp;&amp;
			  last_cwnd_action_ == CWND_ACTION_ECN) {
			       /*
				* if we are in recovery from a recent ECN,
				* don&#39;t cut down ssthresh_.
				*/
				slowdown(CLOSE_CWND_ONE);
				if (frto_enabled_ || sfrto_enabled_) {
					frto_ = 1;
				}
			}
			else {  //
				++nrexmit_;         //ÖØ´«³¬Ê±¼ÆÊý£«1
				last_cwnd_action_ = CWND_ACTION_TIMEOUT;   //¼ÇÂ¼±¾´Î³¬Ê±
				slowdown(CLOSE_SSTHRESH_HALF|CLOSE_CWND_RESTART); //³¬Ê±£¬ssthresh¼õ°ë£¬cwndÖØÆô¶¯
				if (frto_enabled_ || sfrto_enabled_) {
					frto_ = 1;
				}
			}
		}
		/* if there is no outstanding data, don&#39;t back off rtx timer */
		if (highest_ack_ == maxseq_ &amp;&amp; restart_bugfix_) {   	//ÎÞÏÔÖøÊý¾Ý£¬ÖØÐÂÉèÖÃÖØ´«¶¨Ê±Æ÷
			reset_rtx_timer(0,0);
		}
		else {
			reset_rtx_timer(0,1);         //ÕâÊÇ·¢ËÍµÄÊý¾ÝÓÐÎ´ÊÕµ½ACKµÄÇé¿ö,ÕâÊ±ÊÇÖØ´«£¬backoff£½1£¬Ê¹RTO·­±¶
		}
		last_cwnd_action_ = CWND_ACTION_TIMEOUT;  //¼ÇÂ¼±¾´Î³¬Ê±
		send_much(0, TCP_REASON_TIMEOUT, maxburst_);   //ÖØ´«¾¡¿ÉÄÜ¶àµÄÊý¾Ý
	} 
	else {
		timeout_nonrtx(tno);         //²»ÊÇ³¬Ê±ÖØ´«µÄÇé¿ö£¬Èç£ºtno == TCP_TIMER_DELSND
	}
}



/* 
 * Check if the packet (ack) has the ELN bit set, and if it does, and if the
 * last ELN-rxmitted packet is smaller than this one, then retransmit the
 * packet.  Do not adjust the cwnd when this happens.
 */
void TcpAgent::tcp_eln(Packet *pkt)
{
        //int eln_rxmit;
        hdr_tcp *tcph = hdr_tcp::access(pkt);
        int ack = tcph-&gt;seqno();

        if (++dupacks_ == eln_rxmit_thresh_ &amp;&amp; ack &gt; eln_last_rxmit_) {
                /* Retransmit this packet */
                output(last_ack_ + 1, TCP_REASON_DUPACK);
                eln_last_rxmit_ = last_ack_+1;
        } else
                send_much(0, 0, maxburst_);

        Packet::free(pkt);
        return;
}



/*
 * This function is invoked when the connection is done. It in turn
 * invokes the Tcl finish procedure that was registered with TCP.
 */
void TcpAgent::finish()
{
	Tcl::instance().evalf(&quot;&percnt;s done&quot;, this-&gt;name());
}



void RtxTimer::expire(Event*)
{
	a_-&gt;timeout(TCP_TIMER_RTX);
}



void DelSndTimer::expire(Event*)
{
	a_-&gt;timeout(TCP_TIMER_DELSND);
}



void BurstSndTimer::expire(Event*)
{
	a_-&gt;timeout(TCP_TIMER_BURSTSND);
}

/*
 * THE FOLLOWING FUNCTIONS ARE OBSOLETE, but REMAIN HERE
 * DUE TO OTHER PEOPLE&#39;s TCPs THAT MIGHT USE THEM
 *
 * These functions are now replaced by ecn() and slowdown(),
 * respectively.
 */



/*
 * Respond either to a source quench or to a congestion indication bit.
 * This is done at most once a roundtrip time;  after a source quench,
 * another one will not be done until the last packet transmitted before
 * the previous source quench has been ACKed.
 */
//²»±»µ÷ÓÃ£¿ÊÇ·ñÆäËû·ÇtahoeµÄTCPÐ­ÒéÊ¹ÓÃ£¿
void TcpAgent::quench(int how)
{
	if (highest_ack_ &gt;= recover_) {
		recover_ =  maxseq_;
		last_cwnd_action_ = CWND_ACTION_ECN;
		closecwnd(how);
	}
}



/*
 * close down the congestion window
 */
//½ö½ö±»quenchËùµ÷ÓÃ
void TcpAgent::closecwnd(int how)
{   
	static int first_time = 1;
	if (first_time == 1) {
		fprintf(stderr, &quot;the TcpAgent::closecwnd() function is now deprecated, please use the function slowdown() instead\n&quot;);
	}
	switch (how) {
	case 0:
		/* timeouts */
		ssthresh_ = int( window() / 2 );
		if (ssthresh_ &lt; 2)
			ssthresh_ = 2;
		cwnd_ = int(wnd_restart_);
		break;

	case 1:
		/* Reno dup acks, or after a recent congestion indication. */
		// cwnd_ = window()/2;
		cwnd_ = decrease_num_ * window();
		ssthresh_ = int(cwnd_);
		if (ssthresh_ &lt; 2)
			ssthresh_ = 2;		
		break;

	case 2:
		/* Tahoe dup acks  		
		 * after a recent congestion indication */
		cwnd_ = wnd_init_;
		break;

	case 3:
		/* Retransmit timeout, but no outstanding data. */ 
		cwnd_ = int(wnd_init_);
		break;
	case 4:
		/* Tahoe dup acks */
		ssthresh_ = int( window() / 2 );
		if (ssthresh_ &lt; 2)
			ssthresh_ = 2;
		cwnd_ = 1;
		break;

	default:
		abort();
	}
	fcnt_ = 0.;
	count_ = 0;
}



/*
 * Check if the sender has been idle or application-limited for more
 * than an RTO, and if so, reduce the congestion window.
 */
void TcpAgent::process_qoption_after_send ()
{
	int tcp_now = (int)(Scheduler::instance().clock()/tcp_tick_ + 0.5);
	int rto = (int)(t_rtxcur_/tcp_tick_) ; 
	/*double ct = Scheduler::instance().clock();*/

	if (!EnblRTTCtr_) {
		if (tcp_now - T_last &gt;= rto) {
			// The sender has been idle.
		 	slowdown(THREE_QUARTER_SSTHRESH|TCP_IDLE) ;
			for (int i = 0 ; i &lt; (tcp_now - T_last)/rto; i ++) {
				slowdown(CWND_HALF_WITH_MIN|TCP_IDLE);
			}
			T_prev = tcp_now ;
			W_used = 0 ;
		}
		T_last = tcp_now ;
		if (t_seqno_ == highest_ack_+ window()) {
			T_prev = tcp_now ; 
			W_used = 0 ; 
		}
		else if (t_seqno_ == curseq_-1) {
			// The sender has no more data to send.
			int tmp = t_seqno_ - highest_ack_ ;
			if (tmp &gt; W_used)
				W_used = tmp ;
			if (tcp_now - T_prev &gt;= rto) {
				// The sender has been application-limited.
				slowdown(THREE_QUARTER_SSTHRESH|TCP_IDLE);
				slowdown(CLOSE_CWND_HALF_WAY|TCP_IDLE);
				T_prev = tcp_now ;
				W_used = 0 ;
			}
		}
	} else {
		rtt_counting();
	}
}



/*
 * Check if the sender has been idle or application-limited for more
 * than an RTO, and if so, reduce the congestion window, for a TCP sender
 * that &quot;counts RTTs&quot; by estimating the number of RTTs that fit into
 * a single clock tick.
 */
//½ö±»process_qoption_after_send ()Ëùµ÷ÓÃ£¬²»¿´
void
TcpAgent::rtt_counting()
{
        int tcp_now = (int)(Scheduler::instance().clock()/tcp_tick_ + 0.5);
	int rtt = (int(t_srtt_) &gt;&gt; T_SRTT_BITS) ;

	if (rtt &lt; 1) 
		rtt = 1 ;
	if (tcp_now - T_last &gt;= 2*rtt) {
		// The sender has been idle.
		int RTTs ; 
		RTTs = (tcp_now -T_last)*RTT_goodcount/(rtt*2) ; 
		RTTs = RTTs - Backoffs ; 
		Backoffs = 0 ; 
		if (RTTs &gt; 0) {
			slowdown(THREE_QUARTER_SSTHRESH|TCP_IDLE) ;
			for (int i = 0 ; i &lt; RTTs ; i ++) {
				slowdown(CWND_HALF_WITH_MIN|TCP_IDLE);
				RTT_prev = RTT_count ; 
				W_used = 0 ;
			}
		}
	}
	T_last = tcp_now ;
	if (tcp_now - T_start &gt;= 2*rtt) {
		if ((RTT_count &gt; RTT_goodcount) || (F_full == 1)) {
			RTT_goodcount = RTT_count ; 
			if (RTT_goodcount &lt; 1) RTT_goodcount = 1 ; 
		}
		RTT_prev = RTT_prev - RTT_count ;
		RTT_count = 0 ; 
		T_start  = tcp_now ;
		F_full = 0;
	}
	if (t_seqno_ == highest_ack_ + window()) {
		W_used = 0 ; 
		F_full = 1 ; 
		RTT_prev = RTT_count ;
	}
	else if (t_seqno_ == curseq_-1) {
		// The sender has no more data to send.
		int tmp = t_seqno_ - highest_ack_ ;
		if (tmp &gt; W_used)
			W_used = tmp ;
		if (RTT_count - RTT_prev &gt;= 2) {
			// The sender has been application-limited.
			slowdown(THREE_QUARTER_SSTHRESH|TCP_IDLE) ;
			slowdown(CLOSE_CWND_HALF_WAY|TCP_IDLE);
			RTT_prev = RTT_count ; 
			Backoffs ++ ; 
			W_used = 0;
		}
	}
	if (F_counting == 0) {
		W_timed = t_seqno_  ;
		F_counting = 1 ;
	}
}



void TcpAgent::process_qoption_after_ack (int seqno)
{
	if (F_counting == 1) {
		if (seqno &gt;= W_timed) {
			RTT_count ++ ; 
			F_counting = 0 ; 
		}
		else {
			if (dupacks_ == numdupacks_)
				RTT_count ++ ;
		}
	}
}



void TcpAgent::trace_event(char *eventtype)
{
	if (et_ == NULL) return;
	int seqno = t_seqno_;
	char *wrk = et_-&gt;buffer();
	char *nwrk = et_-&gt;nbuffer();
	if (wrk != 0)
		sprintf(wrk,
			&quot;E &quot;TIME_FORMAT&quot; &percnt;d &percnt;d TCP &percnt;s &percnt;d &percnt;d &percnt;d&quot;,
			et_-&gt;round(Scheduler::instance().clock()),   // time
			addr(),                       // owner (src) node id
			daddr(),                      // dst node id
			eventtype,                    // event type
			fid_,                         // flow-id
			seqno,                        // current seqno
			int(cwnd_)                         //cong. window
			);
	
	if (nwrk != 0)
		sprintf(nwrk,
			&quot;E -t &quot;TIME_FORMAT&quot; -o TCP -e &percnt;s -s &percnt;d.&percnt;d -d &percnt;d.&percnt;d&quot;,
			et_-&gt;round(Scheduler::instance().clock()),   // time
			eventtype,                    // event type
			addr(),                       // owner (src) node id
			port(),                       // owner (src) port id
			daddr(),                      // dst node id
			dport()                       // dst port id
			);
	et_-&gt;trace();
}


/*
½áÂÛ1£º½ÓÊÕRECVºÍ·¢ËÍOUTPUTÊ±¶¼Ã»ÓÐÈ¥/×Ô¶Ô·½µÄ´°¿Ú´óÐ¡Í¨¸æ£¬
ÓµÈû½öÆ¾½è×Ô¼ºµÄÍÆËãÀ´½øÐÐ·¢ËÍ¶ËµÄÓµÈû¿ØÖÆ£¬¶Ô¶ËµÄÍ¨¸æ´°¿ÚÉèÎªÒ»¸ö³£Á¿wnd_£¬
±¾¶Ë·¢ËÍ´°¿ÚÎªmin(cwnd_,wnd_)£¬·¶Î§Îª:  highest_ack----highest_ack+win

·¢ËÍ´°¿Ú£º´ÓÎ´È·ÈÏµÄ×îÐ¡ÐòºÅ¿ªÊ¼£¬ÈçÏÂ                        
                   1         2          3          4      
              ----------|----------|----------|---------- 
                     SND.UNA    SND.NXT    SND.UNA        
                                          +SND.WND  


½áÂÛ2£ºÓÐÈý¸ö³¬Ê±¶¨Ê±Æ÷
         rtxtimer        ÓÃÓÚÖØ´«³¬Ê±
         delsndtimer     ÓÃÓÚËæ»ú²úÉúÑÓ³Ù£¬Ä£ÄâÍøÂçµÄÑÓ³Ù£¿·¢ËÍ¶ËÑÓ³Ù£¿
         burstsndtimer   £¿ ÓÃÍ¾²»Ã÷£¬sendmuchÖÐÓÐÒ»¾ä£¬µ«³ÌÐòÖÐÃ»ÓÐÓÃ´¦£¬
                        Ëü³¬Ê±µ÷ÓÃtimeout£¬µ«timeoutºÍtimeout_nonrtxÃ»ÓÐ¶ÔTCP_TIMER_BURSTSNDµÄ´¦Àí
                        ¿ÉÄÜÊÇ·ÇtahoeµÄTCPÐ­ÒéÊ¹ÓÃ
*/

/*
F-RTOËã·¨£º

    ÓÐÈËÖ¸³ö£¬ÖØ´«¶¨Ê±Æ÷¿ÉÄÜÐé¼Ù³¬Ê±£¬ÒýÆðÎ´¶ªÊ§¶Î²»±ØÒªµÄÖØ´«[LK00, GL02,
LM03]¡£ÔÚÐé¼ÙµÄÖØ´«³¬Ê±·¢Éúºó£¬Ô´·¢ËÍ¶Î³Ùµ½µÄÈ·ÈÏµ½´ïÁË·¢ËÍ·½£¬Í¨³£»áÔÚRTO
»Ö¸´ÆÚ¼ä´¥·¢Ò»¸ö²»±ØÒªµÄÕû¸ö´°¿ÚµÄÖØ´«¡£¶øÇÒ£¬ÔÚÐé¼ÙÖØ´«³¬Ê±ºó£¬Í¨³£TCP·¢ËÍ
·½´¦ÓÚÂýÆô¶¯½×¶Î£¬ÔÚ´ËÆÚ¼äÃ¿´ÎÊÕµ½³Ùµ½µÄÈ·ÈÏÊ±£¬¾ÍÊ¹ÓµÈû´°¿ÚÔö¼Ó1¡£ÕâÊ¹ÔÚÒ»
¸öÍù·µÊ±¼äÄÚ£¬´óÁ¿µÄÊý¾Ý¶ÎÓ¿ÈëÍøÂç£¬´Ó¶øÎ¥±³ÁË&ldquo;Êý¾Ý°üÊØºã&rdquo;µÄÔ­Ôò[Jac88]¡£

    µ±RTOµ½ÆÚºó£¬F-RTO·¢ËÍ·½ÏñÍ¨³£Ò»Ñù£¬ÖØ´«µÚÒ»¸öÎ´È·ÈÏ¶Î[APS99]¡£²»Í¬ÓÚ
Í¨³£²Ù×÷µÄÊÇ£¬¶ÔÓÚµÚÒ»¸ö³¬Ê±ºóµÄµ½´ïµÄÈ·ÈÏ£¨¼ÙÉè¸ÃÈ·ÈÏÔÚ´°¿ÚÖ®Ç°£©£¬Ëü¿ªÊ¼
·¢ËÍÐÂµÄ¡¢µ±Ç°Î´·¢ËÍ¹ýµÄÊý¾Ý¡£Èç¹ûÔÚ³¬Ê±ºóµ½´ïµÄµÚ¶þ¸öÈ·ÈÏÔÚ´°¿ÚÖ®Ç°£¨±ÈÈç
Ëµ£ºÎ´±»ÖØ´«µÄÈ·ÈÏÊý¾Ý£©£¬F-RTO·¢ËÍ·½Ðû²¼³¬Ê±ÊÇÐé¼ÙµÄ£¬²¢ÇÒÍË³öRTO»Ö¸´¡£
È»¶ø£¬Èç¹ûÁ½¸öÈ·ÈÏµÄÈÎÒâÒ»¸öÊÇÖØ¸´ACK£¬¾ÍÃ»ÓÐÃ÷ÏÔµÄÖ¤¾Ý±íÃ÷³¬Ê±ÊÇÐé¼Ù³¬Ê±¡£
Òò´Ë£¬´ËÊ±F-RTO·¢ËÍ·½²ÉÓÃ´«Í³µÄÂýÆô¶¯²ßÂÔ£¬ÖØ´«Î´È·ÈÏ¶Î¡£²ÉÓÃSACKÔöÇ¿°æ±¾
µÄF-RTOËã·¨£¬ÔÚRTOÖØ´«ºóÊÕµ½ÖØ¸´ACKÊ±£¬ÈÔÈ»¿ÉÒÔ¼ì²â³öÐé¼Ù³¬Ê±¡£

     Ëã·¨(rfc4138)
    
    1)µ±RTOµ½ÆÚÊ±£¬ÖØ´«µÚÒ»¸öÎ´È·ÈÏ¶Î£¬²¢ÉèSpuriousRecoveryÎªFALSE¡£Í¬Ê±£¬
½«×î¸ßµÄÒÑ·¢ËÍÐòºÅ´æÈë±äÁ¿&ldquo;recover&rdquo;ÖÐ¡£
    
    2)µ±RTOÖØ´«ºóµÄµÚÒ»¸öÈ·ÈÏµ½´ï·¢ËÍ·½£¬·¢ËÍ·½°´ÕÕÊÇ·ñ¸ÃACKÔÚ´°¿ÚÖ®Ç°£¬
»òÊÇ·ñ¸ÃACKÎªÖØ¸´È·ÈÏ£¬Ñ¡ÔñÏÂÃæµÄÆäÖÐÒ»²½¡£

          a)Èç¹û¸ÃÈ·ÈÏÊÇÖØ¸´ACK£¬»òÊÇµÈÓÚ&ldquo;recover&rdquo;ÐòºÅÖµµÄ¶Î£¬»òÊÇÃ»ÓÐÈ·
      ÈÏµÚ1²½ÖØ´«µÄËùÓÐÊý¾Ý£¬Ôò×ª»Øµ½³£¹æµÄRTO»Ö¸´¹ý³Ì£¬¿ªÊ¼ÂýÆô¶¯¹ý³Ì£¬²¢
      ÖØ´«Î´È·ÈÏÊý¾Ý¡£ÇÐÎð½øÈë±¾Ëã·¨µÄµÚ3²½¡£&ldquo;SpuriousRecovery&rdquo;²ÎÊý±£³ÖÎª
      FALSE¡£
    
          b)·ñÔò£¬Èç¹û¸ÃÈ·ÈÏÔÚ´°¿ÚÖ®Ç°²¢ÇÒËüÐ¡ÓÚ&ldquo;recover&rdquo;Öµ£¬·¢ËÍÁ½¸öÐÂ¶Î
      (Ç°ÃæÎ´·¢ËÍ¹ýµÄ¶Î)£¬²¢×ªÈë±¾Ëã·¨µÄµÚ3²½¡£Èç¹ûTCP·¢ËÍ·½Ã»ÓÐ×ã¹»µÄÎ´·¢ËÍ
      Êý¾Ý£¬ÔòÖ»·¢ËÍÒ»¸ö¶Î¡£ÁíÍâ£¬TCP·¢ËÍ·½¿ÉÄÜÂÔ¹ýNagleËã·¨[Nag84]£¬ÐèÒªµÄ
      Ê±ºòÖ±½Ó·¢ËÍÒ»¸ö¶Î¡£×¢Òâ·¢ËÍÁ½¸ö¶Î·ûºÏTCPÓµÈû¿ØÖÆµÄÒªÇó[APS99]£ºF-RTO
      µÄTCP·¢ËÍ·½Ö»ÐèÒªÑ¡Ôñ²»Í¬µÄ¶Î·¢ËÍ³öÈ¥¡£
        
          Èç¹ûTCP·¢ËÍ·½²¢Ã»ÓÐÈÎºÎÐÂµÄÊý¾Ý·¢ËÍ£¬»òÍ¨¸æ´°¿Ú²»ÔÊÐí·¢ËÍÐÂÊý¾Ý£¬
      ÍÆ¼ö²Ù×÷ÊÇÌø¹ý±¾Ëã·¨µÄµÚ3²½£¬°´ÕÕ³£¹æRTO»Ö¸´Ëã·¨£¬¼ÌÐøÂýÆô¶¯ÖØ´«¡£È»¶ø£¬
      Ò»Ð©´¦Àí´°¿ÚÊÜÏÞµÄÌæ»»·½·¨¿ÉÒÔÈ¡µÃ¸üºÃµÄÐÔÄÜ£¬Õâ½«ÔÚ¸½¼þCÖÐÌÖÂÛ¡£
        
    3)µ±RTOÖØ´«ºóµÄµÚ¶þ¸öÈ·ÈÏµ½´ï·¢ËÍ·½Ê±£¬TCP·¢ËÍ·½¿ÉÒÔÑ¡ÔñÐû²¼³¬Ê±ÊÇÐé¼ÙµÄ£¬
    »òÕßÒ²¿ÉÒÔ¿ªÊ¼ÖØ´«Î´È·ÈÏµÄ¶Î¡£
        
          a)Èç¹û¸ÃÈ·ÈÏÊÇÖØ¸´È·ÈÏ£¬½«ÓµÈû´°¿ÚÉèÖÃÎª²»³¬¹ý3&times;MSS£¬²¢ÇÒ¼ÌÐøÂý
      Æô¶¯²ßÂÔ£¬ÖØ´«Î´È·ÈÏµÄ¶Î¡£ÓµÈû´°¿Ú¿ÉÒÔÉèÎª3&times;MSS£¬ÒòÎªÔÚRTO³¬Ê±ºó£¬ÒÑ¾­
      ¹ýÁËÁ½¸öÍù·µÊ±¼ä£¬Í¬Ê±³£¹æµÄTCP·¢ËÍ·½ÒÑ¾­Ôö¼Ócwndµ½ÁË3¡£±£³Ö²ÎÊý
      SpuriousRecoveryÎªFALSE¡£
        
          b)Èç¹û¸ÃÈ·ÈÏÔÚ´°¿ÚÖ®Ç°£¨±ÈÈç£¬ËüÈ·ÈÏÁË³¬Ê±ºóÃ»ÓÐÖØ´«µÄÊý¾Ý£©£¬Ôò
      ÔòÐû²¼³¬Ê±ÊÇÐé¼ÙµÄ£¬ÉèÖÃSpuriousRecoveryÎªSPUR_TO£¬²¢½«&ldquo;recover&rdquo;±äÁ¿Öµ
      ÉèÎªSNA.UNA£¨×îºóÒ»¸öÎ´È·ÈÏµÄÐòºÅ£©¡£
ÌÖÂÛ

    µ±ÖØ´«³¬Ê±ºóÊÕµ½ÖØ¸´È·ÈÏÊ±£¬F-RTO·¢ËÍ·½²ÉÈ¡ÁË½÷É÷µÄ´ëÊ©¡£ÒòÎªÖØ¸´È·ÈÏ
±íÊ¾ÓÐ¿ÉÄÜ¶ÎÒÑ¾­¶ªÊ§£¬ÓÉÓÚÈ±·¦ÆäËûÐÅÏ¢£¬¿É¿¿µØ¼ì²âÒ»¸öÐé¼Ù³¬Ê±ÊÇºÜÀ§ÄÑµÄ¡£
Òò´Ë£¬ÔÚÕâÖÖÇé¿öÏÂ£¬Ëã·¨½÷É÷µØ×ñÑ­ÁË³£¹æµÄTCP»Ö¸´·½·¨¡£

    ÔÚËã·¨(2a)ÖÐ£¬Èç¹ûRTOÖØ´«ºóµÄµÚÒ»¸öÈ·ÈÏº­¸ÇÁË&ldquo;recover&rdquo;µã£¬ÔòÃ»ÓÐÖ¤¾Ý
±íÃ÷³¬Ê±ºóÓÐ·ÇÖØ´«¶Îµ½´ï½ÓÊÕ·½¡£Ò»ÖÖ³£¼ûÇé¿öÊÇ£¬¿ìËÙÖØ´«¶ªÊ§£¬RTO³¬Ê±ºó£¬
¸Ã¶ÎÓÖ±»ÖØ´«,Í¬Ê±£¬ÔÚÖØ´«³¬Ê±ºó£¬ÆäËûµÄÎ´È·ÈÏ¶Î³É¹¦µØËÍµ½TCP½ÓÊÕ¶Ë¡£Òò´Ë£¬
´ËÊ±¸Ã³¬Ê±²»ÄÜÐû²¼Îª¼Ù³¬Ê±¡£  
    
    Èç¹ûRTOÖØ´«ºóµÄµÚÒ»¸öÈ·ÈÏÃ»ÓÐÈ·ÈÏµÚ1²½ÖÐÖØ´«µÄËùÓÐÊý¾Ý£¬TCP·¢ËÍ·½×ªµ½
³£¹æµÄRTO»Ö¸´³ÌÐò¡£·ñÔò£¬²»»³ºÃÒâµÄ½ÓÊÕ·½Ö»È·ÈÏ²¿·ÖÊý¾Ý£¬»áµ¼ÖÂ·¢ËÍ·½»áÔÚ
Êý¾Ý¶ªÊ§Ê±Ðû²¼Ðé¼Ù³¬Ê±¡£

    ÔÚËã·¨·ÖÖ§(2b)ÖÐ£¬TCP·¢ËÍ·½ÔÊÐí·¢ËÍÁ½¸öÐÂ¶Î£¬ÒòÎªÔÚ³£¹æTCPÖÐ£¬RTOÖØ´«
ºó£¬µ±ÊÕµ½ÐÂµÄACK£¬·¢ËÍ·½½«·¢ËÍÁ½¸ö¶Î¡£Èç¹ûÔÚËã·¨·ÖÖ§(2b)ÖÐ²»ÄÜ·¢ËÍÐÂ¶Î£¬
»òÊÇ½ÓÊÕ´°¿ÚÏÞÖÆÁË´«Êä£¬TCP·¢ËÍ·½±ØÐëÒª·¢ËÍÊý¾ÝÒÔ·ÀÖ¹TCPÍ£×ª¡£Èç¹ûÃ»ÓÐÊý¾Ý
·¢ËÍÁË£¬·¢ËÍ·½ºÍ½ÓÊÕ·½ÔÚ¹ÜµÀÔÊÐíµÄ·¶Î§ÄÚ¿ÉÄÜ¶¼ÒÑ¾­·¢ÍêÁË¶Î£¬²»»áÔÙÓÐÏÂÒ»¸ö
È·ÈÏµ½´ï¡£Òò´Ë£¬ÔÚ´°¿ÚÊÜÏÞµÄÇé¿öÏÂ£¬ÍÆ¼ö×ª»Ø³£¹æµÄRTOÂýÆô¶¯ÖØ´«»Ö¸´½×¶Î¡£
¸½¼þCÌÖÂÛÁËÒ»Ð©¿ÉÑ¡µÄ´°¿ÚÊÜÏÞÇé¿ö¡£

    Èç¹ûÖØ´«³¬Ê±±»Ðû²¼ÎªÐé¼Ù£¬TCP·¢ËÍ·½½«&ldquo;recover&rdquo;±äÁ¿ÉèÖÃÎªSNA.UNA£¬
ÒÔÔÊÐí¿ìËÙÖØ´«[FHG04]¡£&ldquo;recover&rdquo;±äÁ¿ÓÃÓÚÔÚNewReno TCP¿ìËÙ»Ö¸´ÆÚ¼ä,µ±RTO
³¬Ê±Ê±£¬±ÜÃâ²»±ØÒªµÄ¡¢³É±¶µÄ¿ìËÙÖØ´«¡£ÒòÎª·¢ËÍ·½Ö»ÖØ´«ÄÄÐ©´¥·¢ÁË³¬Ê±µÄ¶Î£¬
²»±ØÒªµÄ³É±¶¿ìËÙÖØ´«µÄÎÊÌâ²»¿ÉÄÜ·¢Éú¡£Òò´Ë£¬Èç¹û³¬Ê±ºóÓÐ3¸öÖØ¸´ACKµ½´ïÁË
·¢ËÍ·½£¬¾Í±íÊ¾¿ÉÄÜ¶ªÊ§ÁË°ü£¬Ê¹ÓÃ¿ìËÙÖØ´«ÒÔ¼Ó¿ì»Ö¸´Ð§ÂÊ¡£Èç¹û°ü¶ªÊ§ºóÃ»ÓÐ
×ã¹»µÄÖØ¸´ACKµ½´ï½ÓÊÕ·½£¬ÖØ´«¶¨Ê±Æ÷ÓÖ»á³öÏÖ³¬Ê±£¬·¢ËÍ·½¼´×ªÈëËã·¨µÄµÚ1²½¡£
    
    µ±³¬Ê±±»Ðû²¼ÎªÐé¼ÙÊ±£¬TCP·¢ËÍ·½²»ÄÜ¼ì²âµ½ÊÇ·ñ´æÔÚ²»±ØÒªµÄRTOÖØ´«¶ªÊ§¡£
Ô­ÔòÉÏ£¬RTOµÄÖØ´«¶ªÊ§Ó¦¸Ã±»ÊÓÎªÒ»¸öÓµÈûÐÅºÅ¡£Òò´Ë£¬Èç¹ûÔÚ¼ì²âµ½Ðé¼Ù³¬Ê±ºó£¬
F-RTO·¢ËÍ·½Ñ¡ÔñÍêÈ«»¹Ô­µ½ÓµÈû¿ØÖÆ²ÎÊý£¬ÔòÎ¥·´ÓµÈû¿ØÖÆÔ­ÔòµÄ¿ÉÄÜÐÔ½ÏÐ¡¡£
Eifel¼ì²âËã·¨ÓÐÏàËÆµÄÐÔÖÊ£¬ÆäDSACKÑ¡Ïî¿ÉÒÔÓÃÓÚ¼ì²âÊÇ·ñÖØ´«¶Î³É¹¦µØ·¢ËÍµ½
ÁË½ÓÊÕ·½¡£

    F-RTOËã·¨ÔÚTCPÍù·µÊ±¼ä²âËãÖÐÓÐ¸±×÷ÓÃ¡£TCP·¢ËÍ·½ÔÚ¼ì²âµ½Ðé¼Ù³¬Ê±ºó£¬
ÄÜ±ÜÃâ´ó¶àÊý²»±ØÒªµÄÖØ´«£¬ÕâÊ¹·¢ËÍ·½ÄÜ¹»ÔÚÑÓ³ÙµÄ¶ÎÉÏÈ¡µÃÍù·µÊ±¼äµÄ²ÉÑù¡£
Èç¹ûÔÚ²»Ê¹ÓÃTCPÊ±¼ä´ÁÊ±²ÉÓÃ³£¹æµÄRTO»Ö¸´²ßÂÔ£¬ÒòÎªÖØ´«µÄÄ£ºýÐÔ£¬²»»á³öÏÖ
ÕâÖÖÇé¿ö¡£½á¹ûÊÇ£¬Í¬³£¹æTCP±È½Ï£¬ÓÉÓÚ²ÉÓÃÁËF-RTO£¬ÔÚÒòÎª¶ÎµÄÑÓ³Ù¶ø´¥·¢ÁË
Ðé¼Ù³¬Ê±£¬Ê¹RTOÇ÷ÏòÓÚ¸ü¾«È·£¬ÊýÖµ¸ü´ó¡£ÎÒÃÇÏàÐÅÔÚÄÇÐ©ÑÓ³Ù¼â·å½Ï¶àµÄÍøÂç
ÖÐ£¬ÕâÊÇÒ»¸öÓÅÊÆ¡£

    ÔÚÐé¼Ù³¬Ê±ºó£¬´æÔÚF-RTOËã·¨²»ÄÜ±ÜÃâ²úÉú²»±ØÒªÖØ´«µÄÇé¿ö¡£Èç¹û°üÖØÅÅ
Ðò»òÖØ¸´°ü³öÏÖÔÚ´¥·¢Ðé¼Ù³¬Ê±µÄ¶ÎÖÐ£¬ÓÉÓÚÊÕµ½µÄÖØ¸´ACK,F-RTOËã·¨¿ÉÄÜ²»ÄÜ
¼ì²âÐé¼Ù³¬Ê±¡£ÁíÍâ£¬Èç¹ûÐé¼Ù³¬Ê±·¢ÉúÔÚ¿ìËÙÖØ´«ÖÐ£¬ÓÉÓÚÒ»Ð©¶ÎÔÚ¿ìËÙ»Ö¸´´¥
·¢ÖØ¸´ACKÇ°·¢ËÍ£¬F-RTOËã·¨Í¨³£²»ÄÜ¼ì²âÐé¼ÙÖØ´«¡£È»¶ø£¬ÎÒÃÇÈÏÎªÕâÐ©Çé¿ö
ºÜÉÙ³öÏÖ£¬×¢ÒâÔÚF-RTOÃ»ÄÜ¼ì²âµ½Ðé¼Ù³¬Ê±µÄÇé¿öÏÂ£¬Ëü²ÉÓÃÂýÆô¶¯²ßÂÔ£¬ÖØ´«
Î´È·ÈÏ¶Î£¬Í¬³£¹æµÄRTO»Ö¸´·½·¨ÏàËÆ¡£

      
ÓµÈûËã·¨µÄ¾ßÌåÏìÓ¦´ëÊ©¼û  rfc4015

*/</NUM></FTP://FTP.EE.LBL.GOV/PAPERS/CONGAVOID.PS.Z></TSS_SIZE_;></SYS/TYPES.H></MATH.H></STDLIB.H></PRE>
<SCRIPT src="./TcpAgentÏê½â.htm_files/gg_read2.js"></SCRIPT><BR><BR><BR><BR><BR><BR>
<DIV id="Javascript.gg_div" class="gg_div" style="width: 728px; height: 90px; top: 8198px; left: 6px; " align="center">
<SCRIPT type="text/javascript" src="./TcpAgentÏê½â.htm_files/show_ads.js">
</SCRIPT><SCRIPT src="./TcpAgentÏê½â.htm_files/expansion_embed.js"></SCRIPT><SCRIPT src="./TcpAgentÏê½â.htm_files/test_domain.js"></SCRIPT><SCRIPT>window.google_render_ad();</SCRIPT><INS style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px"><INS style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px"><IFRAME allowtransparency="true" frameborder="0" height="90" hspace="0" id="google_ads_frame1" marginheight="0" marginwidth="0" name="google_ads_frame" scrolling="no" src="./TcpAgentÏê½â.htm_files/ads.htm" style="left:0;position:absolute;top:0" vspace="0" width="728"></IFRAME></INS></INS>
<BR>
<SCRIPT src="./TcpAgentÏê½â.htm_files/stat.php" language="JavaScript" charset="gb2312"></SCRIPT><A href="http://www.cnzz.com/stat/website.php?web_id=1236358" target="_blank" title="Õ¾³¤Í³¼Æ"><IMG border="0" hspace="0" vspace="0" src="./TcpAgentÏê½â.htm_files/pic.gif"></A><IMG src="./TcpAgentÏê½â.htm_files/stat.htm" border="0" width="0" height="0">

</DIV></FORM></BODY></HTML>